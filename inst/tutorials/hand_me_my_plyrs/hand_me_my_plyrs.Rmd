---
title: "DoSS Toolkit"
subtitle: "Hand me my plyrs"
date: "18 May 2021"
output: 
  learnr::tutorial:
    allow_skip: true
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(learnr)
library(flair)
# tutorial_options(exercise.eval = FALSE)
library(gradethis)
gradethis::gradethis_setup()
library(palmerpenguins)

broadway <- read_csv(
  "https://raw.githubusercontent.com/tacookson/data/master/broadway-grosses/grosses.csv",
  guess_max = 10000)

broadway <- broadway %>%
  select(week_ending, show, theatre, weekly_gross, avg_ticket_price,
         top_ticket_price, performances, previews)
```





## Introduction

The `tidyverse` is a package that loads a whole bunch of other packages. These allow you to write R in a certain way, called 'tidy'. This is kind of like speaking a dialect of a spoken language. It's still the same language, but it's also different.

The key package within the `tidyverse` is called `dplyr`, which is pronounced 'dee-plier', hence the horrible pun in the title. We're going to cover a lot of different functions here, and it may be a bit overwhelming, but just try to apply them to something that you're interested in, be that [stochastic convergence rates](https://github.com/awstringer1/aghq), [baseball](https://www.hodgettsp.com/blog/baseball-a-defensive-critique/), or [DMC embroidery floss colour](https://sharlagelfand.github.io/dmc/).


<iframe width="560" height="315" src="https://www.youtube.com/embed/l15xQTf1m4A" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>












## What is the tidyverse?

Written by Yena Joo.

### Introduction

In this lesson, you will learn:

- What the `tidyverse` is, and what core packages there are.     
- That with the tools provided by packages in the `tidyverse`, you can save up your time, and focus more on your interpretations and analysis.   
  
In order to analyze or visualize data, you will need a clean, tidy set of data to work with, and sometimes the downloaded data could be too unorganized or contain too much information that is unnecessary. In order to tidy up the data, you would need this tidyverse package. Once you have tidy data, you would want to visualize them, or create a table, or iterate through your data. Tidyverse is a collection of R packages designed for data science, that can do everything I just mentioned above.    

Prerequisite skills include:

- How to install packages!    

You will need to install a package called `tidyverse`.  

```{r}
library(tidyverse)
```

`dplyr`, `ggplot`, `tidyr`, `readr`, `tibble`, and many other packages are part of tidyverse which helps you visualize and manipulate the tidy data. In the following lectures, you will get to learn essential functions often used in the package `tidyverse`. 

Highlights:

- Tidyverse!

### Core `tidyverse` packages

Various packages inside a `tidyverse` package do not need to be installed individually, you can install them at once by executing `install.packages("tidyverse")`. However, when you run `library(tidyverse)`, only a several packages are going to be installed, which is called a 'core tidyverse'. Core tidyverse in `tidyverse` includes: `ggplot2`, `dplyr`, `tidyr`, `readr`, `purrr`, `tibble`, `stringr`, and `forcats`.   

#### `readr`

The `readr` package is used to import data sets such as csv, tsv files. It is designed to parse different types of data you can find online, and turn it in to a clean format so you can use in R. For example, you can use the `readr` package to import csv files as follows:   

``` 
df <- read_csv("any csv file.csv")
```  
  
There are other functions such as:  

- `read_tsv()`: for tab separated files  
- `read_delim()`: for general delimited files  
- `read_log()`: for web log files, and more.  

Typing `vignette("readr")` into the console will provide you a detailed information of the package, such as how readr reads the column types, and tips on how to solve parsing problems.

Also, [here](https://readr.tidyverse.org) is an additional resource you may find helpful.   


#### `tibble`

A tibble is a form of a data frame. The package `tibble` lets you know about the information of the data set you imported. You can confront problems using the package earlier, so you don't run into a problem while you visualize or manipulate your dataset.  

For example, you can create a tibble from scratch using the function `tibble()` with individual vectors as follows:   

```{r}
tibble(
  a = c(1, 2, 3), 
  b = c(10, 11, 12)
)
```
As you can see, `tibble()` does not change the input types or the name of the variables. You can also create tibbles with the function `data_frame()`(and this is different from `data.frame()`!).  

To convert an existing data frame into a tibble, you can use the function `as_tibble()`.  If you want to convert a tibble back to an original data frame, you can use `as.data.frame()` function to do so. In some cases, it may be more convenient to input in row units. In this case, you can use the function `tribble()`.   

Also, note that tibbles will only show the first 10 rows, and only the columns that fit on screen. This feature of the tibble makes easier to check the characteristics of the data on display than using the original data frame.   

If you would like to learn more about `tibble`, [here](https://r4ds.had.co.nz/tibbles.html) is an additional resource you may find helpful.  


#### `tidyr`

The `tidyr` package is used to create tidy data. Tidy data should satisfy the following:  

1. Each variable must have its own column.
2. Each observation must have its own row. 
3. Each value must have its own cell.  
  
This is the standard way of structuring data. If a data set does not satisfy at least one rule, it is considered messy data. We will spend a lot of time cleaning and preparing data - into tidy data - for further analysis, so this package is critical.  
  
The main functions are:  

- Pivoting: This converts between long and wide forms of a dataframe. In the module, functions `pivot_wider()` and  `pivot_longer()` are going to be introduced. Also, see `vignette("pivot")` for more information on pivoting.
- Dealing with missing values: You can drop `NA` values using the function `drop_na()`, or replace missing values with a previous or next value using the function `fill()`. You can also use `replace_na()` to replace with a certain value.  

There are more functions in this package that will make data cleaning easier and more effective. To learn more about tidy data, you may find the paper ["Tidy data"](https://vita.had.co.nz/papers/tidy-data.html) helpful. 

#### `dplyr` 

The `dplyr` package is used to manipulate a data set you created using readr and tidyr.  

- `select()` allows you to choose variables based on their names.  
- `filter()` allows you to choose cases based on their values.  
- `summarise()` turns multiple values into a single summary.  
- `arrange()` allows you to change the order of the rows.  
- `group_by()` allows you to perform the mutation by group.  

These are some good examples of functions you will learn in the module.  

The most representative function supported by `tidyr` and `dplyr` is the pipe operator, `%>%`. By using this operator, it removes the redundancy and inefficiency of duplicated variable names in the code. Not only the pipe operator but there are a lot of other useful functions which makes these two packages essential to learn.  

Here are [more information on dplyr package](https://dplyr.tidyverse.org).  

#### `ggplot2`

The `ggplot2` package is used to create graphics and to visualize data. With the `ggplot()` function, you can create almost every graph you imagine of. using aesthetic mapping `aes()`, `geom_point`, `geom_line`, etc. you can set what kind of layers you would like to include in the graph, with what kind of scales, and many more.   

For example, I can create a scatter plot using `ggplot()` with `geom_point` as follows:    
```{r}
ggplot(mtcars, mapping = aes(mpg, disp)) + geom_point()
```
  
You can fine-tune your graph using faceting specifications, labeling, coordinate systems, changing colours, and more. You can plot almost any type of graphs you could imagine using the package, much more efficiently.    


You can always click [here](https://ggplot2.tidyverse.org) to learn more about ggplot2. 

Note that most of the visualization work in R is performed using `ggplot2` package. So, I recommend you to spend some extra time learning ggplot in future lectures.  

#### `purrr`  

The `purrr` package in tidyverse is all about iterations. By using `purrr`, you can perform loops and iteration tasks more intuitively and easier compared to other built-in functions used for iterations. Regardless of programming language, most of the programming tasks require a good understanding and use of loops, and R requires one too. However, this requirement could be easily improved by using `purrr`.  

For more information on `purrr`, here is an [additional resource on purrr package](https://purrr.tidyverse.org) you may find helpful.   

#### `stringr`  

As you can guess from the package name, `stringr` is a package that provides a set of functions designed to make manipulating strings easier. A string is a one-dimensional array of a bunch of character variables inside single quotes or double-quotes. For example, 

```
"string"   
"This is a string"
"this_is_also_a_string" 
'string123'
```

The following examples are all strings. The package `stringr` allows you to change the string, replace it, split it, count, and many more.   

Here is an [additional resource on stringr package](https://www.rdocumentation.org/packages/stringr/versions/1.4.0) you may find helpful.   


#### `forcats`

The `forcats` package is used to solve problems with factors. Factors are used to handle categorical variables or to reorder character vectors to improve the display.  
Categorical variables in a vector is not as useful as integers in a vector, since strings don't sort well (maybe just in alphabetical order). However, using `factors()` will avoid these problems happening with a simple vector of strings.  

An [additional resource on factors](https://r4ds.had.co.nz/factors.html) may be helpful because a good understanding of `factors` is needed in order to use the package `forcats`. Also, see `vignette("forcats")` for more information on the package `forcats`.   

This is not every package that `tidyverse` contains, but they are the most important core packages and the packages you will use often. For more information on tidyverse, you can always visit the [official tidyverse webpage](https://tidyverse.tidyverse.org).  

### References

- [official tidyverse webpage](https://tidyverse.tidyverse.org). 
- [tidyverse cheatsheet](http://users.encs.concordia.ca/~gregb/home/PDF/R-Tidyverse-Cheat-Sheet.pdf)














## The pipe: %>%

Written by Mariam Walaa.


### Introduction

In this lesson, you will learn how to:

- Load the package required to use the pipe `%>%`
- Use the pipe `%>%`

Prerequisite skills include:

- Loading packages

Highlights:

- The pipe `%>%` is used to keep code clean and concise.
- The pipe `%>%` works by "piping" data into a function.
- The pipe `%>%` can "pipe" data into functions repeatedly.

### Overview

The pipe is helpful for keeping your code clean when you have to apply multiple
transformations to your data.

You can start using the pipe after you've loaded the `magrittr` package. The `magrittr`
package is also part of `tidyverse`, so if you've already loaded `tidyverse` then you'll
be able to start using the pipe.

In this tutorial, we'll be using the `penguins` data to present the uses of the pipe. This
data contains records on measurements for penguin species, including their size, sex, and
where they live. There are 344 rows and 8 columns in this data set.

```{r pipe-image-1, echo = FALSE, out.width="75%"}
knitr::include_graphics("images/32_penguins.png")
```

Figure: The Palmer Penguins
Credits: Allison Horst

Let's start with loading the tidyverse.

```{r load-tidyverse}
library(tidyverse)
```

Here's a simple example using base R's `summary()` without the pipe.

```{r pipe}
summary(penguins)
```

Here's the same code using the pipe.

```{r pipe-1}
penguins %>% summary()
```

As you can see, the pipe `%>%` operator takes the `penguins` data frame and pipes it into
the `summary()` function, so you don't need to pass `penguins` as a parameter to
`summary()`.

In this simple example, it's hard to see why using the pipe makes the code clean and
concise, but when you have multiple transformations that you want to apply to your data,
it becomes clearer why using the pipe makes your code cleaner, more concise, and easier to
read.

Here's a similar example without the pipe, but this time we'll filter the data before we
summarize.

```{r pipe-2}
adelie <- filter(penguins, species == "Adelie")
summary(adelie)
```

Here's the same example using the pipe.

```{r pipe-3}
penguins %>%
  filter(species == "Adelie") %>%
  summary()
```

The code looks a lot cleaner, and we didn't have to separate the process into two
different steps or assign the filtered data to a new data frame object.

### Exercises

You can learn more about the penguins through this illustration.

```{r pipe-image-2, echo = FALSE, out.width="75%"}
knitr::include_graphics("images/32_culmen_depth.png")
```

Figure: The Palmer Penguins
Credits: Allison Horst

#### Exercise 1

Here is some code that filters the data by species and sex, and summarizes the data.

```{r pipe-4}
adelie <- filter(penguins, species == "Adelie")
female_adelie <- filter(adelie, sex == "female")
summary(female_adelie)
```

Convert this into equivalent code using the pipe.

```{r pipe-exercise-1, exercise = TRUE}

```

```{r pipe-exercise-1-hint-1}
# You don't have to assign it to an object
```
```{r pipe-exercise-1-hint-2}
# You can filter multiple times within filter()
```

```{r pipe-5-exercise-1-solution, echo = FALSE}
pipe_ex1_sol <- penguins %>% 
  filter(species == "Adelie",
         sex == "female") %>%
  summary()
```


<!-- ```{r pipe-exercise-1-check} -->
<!-- grade_result(pass_if(~identical(.result, pipe_ex1_sol))) -->
<!-- ``` -->

#### Exercise 2

Here is some code that filters the data by sex and year of study, and counts the number of
penguins.

```{r pipe-6}
females <- filter(penguins, sex == "female")
females_2007 <- filter(females, year == "2007")
count(females_2007)
```

Convert this into equivalent code using the pipe.

```{r pipe-exercise-2, exercise = TRUE}

```

```{r pipe-exercise-2-hint-1}
# You don't have to assign it to an object
```

```{r pipe-6-exercise-2-solution, echo = FALSE}
pipe_ex2_sol <- penguins %>% 
  filter(sex == "female",
         year == "2007") %>%
  count()
```


<!-- ```{r pipe-exercise-2-check} -->
<!-- grade_result(pass_if(~identical(.result, pipe_ex2_sol))) -->
<!-- ``` -->

#### Exercise 3

```{r pipe-exercise-3, echo = FALSE}
question("Which of these are true? Check all true statements.",
         answer(paste("The pipe is not a required operator in your code, but it's helpful",
         " to have because it makes code cleaner."), correct = TRUE),
         answer(paste("The pipe makes your code look cleaner by expressing multiple ",
         "transformations in one line of code."), correct = TRUE),
         answer(paste("The pipe can take 'pipe' both data frames and functions into ",
         "other functions."), message = "The pipe only 'pipes' data into functions."),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

### Common Mistakes & Errors

Below are some common mistakes and errors you may come across:

- You might type the wrong operator. The pipe operator is as follows: `%>%`
- You might try to pipe something into a function other than data. 

### Next Steps

If you would like to read more about the pipe operator, here are some additional
resources you may find helpful:

- [R For Data Science: Chapter 18 - Pipes](https://r4ds.had.co.nz/pipes.html)













## `select()`

Written by Yena Joo.

### Introduction

#### What is `select()`?

In this lesson, we will learn how to use the `select` function.  


When you're working with data, you find there are way too many variables in it, and some would wonder, how do I select only the variables I want to use for the analysis? Well, there is a super easy way to see the variables you choose by referring to variables based on the name of the column, with just one simple function.  

`select()` is a function that keeps only the variables you specify.  

The output of the function is a subset of the input data (columns), potentially with a different order. However, the function `select()` does not mutate the original dataset/columns. So if you want to use the new columns you selected, you will have to assign the value to a new variable.  

#### Prerequisite skills include  
- You should have a good understanding of data (column, row, variable), and how to import data.  
- You also have to know how to use pipe (`%>%`) 

#### Basic setup

```{r}
library(tidyverse)
```


### Video

<iframe width="560" height="315" src="https://www.youtube.com/embed/4_8QnnKuO0M" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


### Basics

Here is a simple dataset that has average temperatures for each season. As you can see in the outcome, there are 3 observations(rows) and 4 variables(columns) in the dataset.

```{r echo = F}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 
temperature_data
```

Now, let's say we want to only see temperatures in the Spring. To do so, select variables you would like to keep by putting the variable name in the parameter with the function `select`.  
Here, I would like to just see the `spring` column by writing the code as below:

```{r}
select(temperature_data, spring)
```

However, it is important to know that the data in `temperature_data` did not change as you can see. The function does not mutate the original dataset.

```{r}
temperature_data
```


If you want to use the new dataset with the variable `spring`, you would have to assign the selected column(s) to a new variable:

```{r}
new_data = select(temperature_data, spring)
new_data
```




### Operators 

Now, we know how to use the function `select` bare minimum. There are various ways to use the function with some operators.  


**1. You can select multiple variables using commas. Order of the input matters!**    

```{r}
select(temperature_data, winter, summer)
```


**2. Another way of selecting multiple variables is to use the operator `c()`.**  
`c()` is a function that returns a vector(a one-dimensional array). Order of the input also matters.  

```{r}
temperature_data %>%
select(c(winter, fall))
```
  
  

**3. The `!` operator negates a selection, `&` operator means "and"(intersection), whereas `|` takes the union of the selections (or).**

```{r}
temperature_data %>%
select(!winter)
select(temperature_data, !winter & !summer)
```

`select(temperature_data, winter & summer)` would incur an error because there cannot exist a variable that is both winter and summer.    



**4. The `:` operator selects a range of consecutive variables, starting from the variable you put on the left of the colon to the variable you put on the right of the colon.**  

```{r}
temperature_data %>% 
  select(summer:winter)
```


**5. The `-` operator excludes a column.**  

If you would like to choose most of the columns in the dataset, and exclude a few columns, there is an easier way. You can just put `-` in front of the name of the column you would like to exclude. For example, I would like to exclude columns `summer` and `winter`, then I would just put a `-` in front of the columns:    

```{r}
temperature_data %>% 
  select(-summer, -winter)
```

### Advanced uses

Some would wonder how they could select the columns based on the data types, since most of the statistical analyses use quantitative data rather than qualitative data. In that case, you can use the following:  

`select(which(sapply(., is.numeric)))`  

Instead of `is.numeric`, you can put `is.character` and `is.double` depending on what type of variables you would like to select in the dataset. 
Let's look at some examples. Here is a dataset that contains information about Sakura blooming in Japan, and it has various data types such as `<int>`(integer), `<chr>`(character), `<dbl>`(double). 

```{r}
japanese_blooming <- read.csv("https://raw.githubusercontent.com/tacookson/data/master/sakura-flowering/temperatures-modern.csv")
head(japanese_blooming)
```

Using the `which(sapply(., is.character))`, we can select the variables that have a data type character `<chr>`.  

```{r}
japanese_blooming %>% select(which(sapply(.,is.character)))
```

If you want to select quantitative/numeric data, you can put `is.numeric` instead.  

```{r}
japanese_blooming %>% select(which(sapply(.,is.numeric)))
```

  

Another way to perform, is the following using `select_if` with whichever data type you would like to select, such as `is.double`, `is.integer`, `is.double` and `is.character`:

```{r}
japanese_blooming %>% select_if(is.double)
```

Selecting variables depending on the data type will come in handy when the dataset has hundreds of variables and you would like to select only quantitative variables for your data analysis/building a statistical model. 



### Exercises

Based on the material we have learned, now let's do some exercises.  


#### Question 1

Modify this code so that we can only see from second to fourth column.

```{r q1_select, exercise.eval = TRUE, exercise=TRUE}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 

select(temperature_data, 4:4)
```
```{r q1_select-solution}
select(temperature_data, 2:4)
```

The outcome should be: 
```{r q1_select-a, echo = F}
select(temperature_data, 2:4)
```
  

#### Question 2 

Modify this code so that we can only see the columns "winter" and "summer" respectively, using `|` operator. 

```{r q2_select, exercise.eval = TRUE, exercise=TRUE}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 

select(temperature_data, spring)
```
```{r q2_select-solution}
select(temperature_data, winter|summer)
```

The correct answer should have a result like: 

```{r echo = F}
select(temperature_data, winter|spring)
```



#### Question 3

```{r q3_select, echo=F}
question_checkbox(
  "There are variables 'id', 'gpa', 'age', 'height', 'weight' are in a dataset 'data'. You would like to select only variables 'id', 'height', and 'weight'. What should I write? (Select all that apply) ",
  answer("data %>% select(id, height, weight)", correct = T),
  answer("data %>% select(id & height & weight)", message = "When is the `&` operator used? Check the 'Operations' section."),
  answer("data %>% select(id | height | weight)", correct = T),
  answer("data %>% select(id | height:weight)", correct = T),
  allow_retry = T,
  random_answer_order = T,
  incorrect = "Try again. You got this!"
)
```

#### Question 4

Here is the dataset about ratings of children's books called `child_book_data`. 
```{r echo = F}
#x <- getURL("https://raw.githubusercontent.com/tacookson/data/master/childrens-book-ratings/childrens-books-normalized-ratings.txt")
child_book_data <- read.delim("https://raw.githubusercontent.com/tacookson/data/master/childrens-book-ratings/childrens-books-normalized-ratings.txt")
head(child_book_data)
```

Select the columns that only are type `<dbl>` or if the column has a name `isbn`.

```{r q4_select, exercise.eval = TRUE, exercise=TRUE}
child_book_data <- read.delim("https://raw.githubusercontent.com/tacookson/data/master/childrens-book-ratings/childrens-books-normalized-ratings.txt")
head(child_book_data)

child_book_data %>% select(isbn)
```

```{r q4_select-solution}
child_book_data %>% select(isbn|which(sapply(.,is.double)))
```




### Common Mistakes & Errors

- If you don't have package "dplyr" or "tidyverse" installed and called in the library, the function would not work. Download either package using `install.packages("dplyr")`, and set it up in the library at the start of your code using `library(dplyr)`.  
- Make sure you typed in the correct variable/column name. Always check if your code contains any typo.  
- If you would like to use the new data frame using the variables you have selected, make sure to assign the selected variables to a new data frame.  
- Make sure you understand the differences between the operator `&` and `|`. They can be confusing.  


### Next Steps & See also 

In the tidyverse essentials, there are a ton of other functions you could mix & match with. After learning other functions such as `filter()`, `group_by()`, `arrange()`, `mutate()`, etc. you could easily modify the dataset according to your taste. 
  
### Summary

- package `tidyverse` or `dplyr` is needed.   
- `select()` keeps only the variables you mention.   
- There are some operators that can come in handy.  
  1. `|`: OR operator  
  2. `&`: AND operator  
  3. `c()`: a function that returns a vector, it is for choosing multiple columns. 
  4. `!`: to negate a statement or a column  
  5. `-`: to exclude a column   
  6. `:`: to select a range of consecutive variables  
- If you want to select columns with a specific data type, use `which(sapply(.,is.DATATYPE))` or use `select_if(is.DATATYPE)`  
  











## `filter()`

Written by Shirley Deng.


### What is `dplyr::filter()` for?

The `dplyr::filter()` function is used to extract rows from a given dataframe following given criteria, and any rows that do not meet this criteria are dropped.

This criteria is written in the form of logical conditions that can be evaluated. For example, if a dataframe `ToothGrowth` has a variable called `len` for lengths, we can extract all of the rows such that `len` is equal to 22.0 with the expression `len == 22.0`. We can have one single condition, or several conditions.

Some useful functions and operators include the following:

*  `==`, `>`, `<`, `>=`, `<=`
* `&`, `|`, `!`, `xor()`
* `is.na()`

`dplyr::filter()` is similar to extracting a subset of rows with square brackets in base R, `[]`. However, in the case that evaluating our conditions on a row results in `NA`s, `dplyr::filter()` drops these rows whereas `[]` would continue to extract them. For this reason, `dplyr::filter()` may be preferred when there may be `NA`s.


### What arguments does `dplyr::filter()` take?

* `.data`: the dataframe we're working with
* `...`: the conditions for the rows we want to extract
* `.preserve`: whether or not we want to preserve the grouping of the `.data` dataframe

### What value does `dplyr::filter()` return?

`dplyr::filter()` returns a dataframe retaining all of the same characteristics as the `.data` argument, except only a subset of the rows, based on the conditions or criteria we used to extract this subset. Namely, this means that the columns are unmodified, and the order of the rows remains the same.

### Practice 

How can we check if 2+2 is greater than or equal to 2*2? Try coding it below.

```{r two-plus-two, exercise=TRUE}

```

```{r two-plus-two-hint}
2+2 >= 2*2
```

### Coding Examples

The following is code similar to that from the video lesson in the previous section.

First, we begin by installing the `dplyr` package:

```{r video-installing, eval = FALSE}
install.packages("dplyr", repos = "http://cran.us.r-project.org")
```

Next, we load the `dplyr` package:

```{r video-package}
library(dplyr)
```

Now, we want to prepare a dataframe for us to work with. We will make use of the `ToothGrowth` dataset built into R. 

We can take a look at what this dataset is about:

```{r video-ToothGrowth-info}
?ToothGrowth
```

And take a look at the first few rows of observations:

```{r video-ToothGrowth-head}
head(ToothGrowth)
```

We want to add an additional variable for the colour of the guinea pigs.

We need to set a seed to ensure we get the same results every time the code is run. We chose the number `123`:

```{r video-seed}
set.seed(123)
```

Now, we create our colour variable by taking a sample of guinea pig fur colours. We use the `sample()` function for this:

```{r video-sample}
colour <- sample(x=c("black", "brown", "grey", "cream", "white", "multi"),
                 size=nrow(ToothGrowth),
                 replace=TRUE)
colour
```

And now we create a new dataframe that combines `ToothGrowth` with our `colour` variable using `data.frame()`. We'll also take a look at the frist few observations.

```{r video-df}
guineas <- data.frame(ToothGrowth, colour)
head(guineas)
```

We notice that it looks the same as the original `ToothGrowth` dataframe, but with our added `colour` variable.

We can now move onto trying out the `dplyr::filter()` function!

First, we try extracting a subset of rows using only one condition: that the guinea pigs are brown in colour.

```{r video-1}
brown_guineas <- filter(guineas, colour == "brown")
brown_guineas
```

Next, we try using two conditions: that the guinea pigs are white in colour, and received a supplement dosage of 1.0 mg/day.

```{r video-2}
white_1_guineas <- guineas %>% filter(colour == "white", dose == 1.0)
white_1_guineas
```

Now, we want to see what happens when our conditions evaluate as `NA`s.

First, we try a condition that evaluates all of the rows as `NA`s with `dplyr::filter()`:

```{r video-NAs-filter}
no_guineas <- guineas %>% filter(dose/0 == 2)
no_guineas
```

And now with the square brackets `[]` in base R:

```{r video-NAs-square}
some_guineas <- guineas[guineas$dose /0 == 2]
some_guineas
```

We notice that using `dplyr::filter()` we extracted no rows, whereas using the square brackets we extracted all of the rows but no columns.

Lastly, we want to see how `dplyr::filter()` works on grouped dataframes.

We begin by greating a grouped version of our `guineas` dataframe, through grouping by colour:

```{r video-grouping}
grouped_guineas <- guineas %>% group_by(colour)
grouped_guineas
```

And then we try filtering by receiving orange juice as the supplement, while preserving the grouping:

```{r video-preserve}
orange_grouped_guineas <- grouped_guineas %>% filter(supp == "OJ", preserve=TRUE)
orange_grouped_guineas
```


### Exercises

Let's go over some common mistakes, and then try using the filter() function ourselves.

Make sure you're using `==` instead of `=`. Try changing the `==` to `=` below:
```{r equal-mistake, exercise=TRUE}
filter(guineas, colour == "brown")
```

Make sure you're using quotation marks for strings, or R will read them as variable names. Try removing the quotation marks around `brown` below:
```{r string-mistake, exercise=TRUE}
filter(guineas, colour == "brown")
```

Onto the exercises!

Extract all guinea pigs that were given the ascorbic acid Vitamin C supplement.

```{r vc, exercise=TRUE}

```

``` {r vc-hint}
guineas %>% filter(supp=="VC")
```

Extract all guinea pigs that were given the orange juice supplement at a dose of 0.5 mg/day.

```{r oj-half, exercise=TRUE}

```

``` {r oj-half-hint}
guineas %>% filter(supp=="OJ", dose==0.5)
```


### Additional Resources

* [`dplyr:filter()` reference page](https://dplyr.tidyverse.org/reference/filter.html)












## `group_by()` and `ungroup()`

Written by Matthew Wankiewicz.


### Introduction

In this lesson, you will learn how to:

- Use the `group_by()` function in R
- Use the `group_by()` function with other functions in R.

Prerequisite skills include:

- Having R installed on your computer/Having RStudio Cloud.
- Having `tidyverse` installed on R.

Highlights:

- The `group_by` function allows you to group datasets by variables you choose.
- `group_by` works best when paired with other dplyr functions, either counting the number of items in a group or making new variables from groups.

![Image Source:https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/group_by_ungroup.png, Allison Horst](https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/group_by_ungroup.png){width=400 height=300}

### The content

A major part of data analysis is seeing how your data looks using particular groups and the `group_by` function is very helpful with this. The `group_by` function takes a data frame and allows you to use other functions to get an idea of what these groups look like. 

The `group_by` function is useful for conducting operations on your dataset when you want to break up the points by group. For example, if you have a data frame with the heights and weights of different animals, the `group_by` function is useful for finding things like the mean weight of each type of animal in the data frame. The function `ungroup` is used to remove the grouping done by the `group_by` function.

Normally, the `group_by` function is paired with other dplyr functions in order to conduct your analysis.

The `ungroup` function takes one argument, a grouped data frame that you want to ungroup. This is useful for ungrouping your data after you have run your analysis and want to work with the whole data frame again.

Brief Overview of the `group_by()` and `ungroup()` functions:

<iframe width="560" height="315" src="https://www.youtube.com/embed/011h7uREXAU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Arguments

- **`group_by()`**: The two main arguments for `group_by` are the data you plan to analyze and variables you want to group. When you enter in the data you plan to analyze, it will be the first argument. You can either write the name of the dataset as the first argument or pipe it into the `group_by()` function. Once you have your dataset in the function, you then have to write in the variable names you plan to group. You can write as many variables as you want when using `group_by()`.

- **`ungroup()`**: The `ungroup()` function takes one argument, the grouped data that you want to ungroup. This is useful for ungrouping your data after you have run your analysis and want to work with the whole data frame again.


### Other Optional Arguments

- **`group_by()`**: The two optional arguments are .add and .drop. .add determines whether or not the function makes new groups in the data. .drop drops groups that were formed before-hand which we may not see in the data.

### Questions

```{r example_1Groupby, exercise = T}
penguins_grouped <- penguins %>% 
  group_by(species)
head(penguins_grouped)
```

As you can see above, using the `group_by` function does not appear to do anything when it is done on its own. When you have a grouped data frame, you usually pair it with another function to get the data you want.

```{r example_2Groupby, exercise = T}
penguins %>% 
  count()
```

The chunk above takes the penguins data frame and counts how many observations are included. The output is only one number which represent all of the penguins. In the chunk below, we will use the `group_by` function to see the number of penguins of each species present in the data frame.

```{r example_3Groupby, exercise=T}
penguins %>% 
  group_by(species) %>% 
  count()
```

In the chunk above, I used the grouped data frame that was created in the chunk before and ran it with the `count` function. This allows us to see how many penguins of each species are present in the data frame.


```{r example_4Groupby, exercise=T}
penguins %>% 
  group_by(species) %>% 
  # use na.rm to remove missing values
  summarise(average_weight = mean(body_mass_g, na.rm = T))
```

This chunk shows how we can use the `group_by` function with the `summarise` function to get summary statistics for each species. To do this, you can either take the grouped data frame and pipe it into the `summarise` function or you can use the `group_by` function on the initial data frame and then pipe that into the `summarise` function.


```{r example_5Groupby, exercise=T}
penguins %>% 
  group_by(species) %>% 
  summarise(average_weight = mean(body_mass_g, na.rm = T),
            average_flipper_length = mean(flipper_length_mm, na.rm = T))
```

This is an example of using the `group_by` function and the `summarise` function after piping in your initial data frame. As you can see, there is another column present in the output, compared to the chart above. This was done by adding in another argument to the `summarise` function which now gives us the average flipper length of each species of penguin.

```{r example_6Groupby, exercise=T}
penguins %>% 
  group_by(species, sex) %>% 
  summarise(average_weight = mean(body_mass_g, na.rm = T))
```
The `group_by` function can also be used with multiple variables. This is an example of using two variables to group our data, this time we will use species and sex. Once again, we can see that visually, the data doesn't look different but when we apply other functions to it, the data will appear differently. 

```{r example_7Groupby, exercise=T}
penguins %>% 
  group_by(species, sex, year) %>% 
  summarise(average_weight = mean(body_mass_g, na.rm = T))
```

This output shows us the average weights of the penguins, when grouped by species and sex. We can see that there are levels for each of the three species (Adelie, Chinstrap and Gentoo) and the three gender levels present (Male, Female and NA).

```{r example_8Groupby, exercise=T}
penguins %>% 
  group_by(species, sex) %>% 
  filter(body_mass_g == max(body_mass_g))
```

The `group_by` function also works with the `filter` function. The chunk above gives us the penguins with the largest body mass for each of the groups we created. 

```{r example_9Groupby, exercise=T}
penguins %>% 
  group_by(species) %>% 
  count()

penguins %>% 
  group_by(species) %>% 
  ungroup() %>% 
  count()
```

This chunk demonstrates the `ungroup` function. The output of the first code is the same as one of the previous examples, it gives us the number of penguins present for each species. 

The second group of code shows us what `ungroup` does. The `ungroup` function was placed just before the `count` function so instead of giving us the number of penguins in each species, we get the number of penguins in the whole data frame.

**Brief Overview of the `group_by()` and `ungroup()` functions**:

<iframe width="560" height="315" src="https://www.youtube.com/embed/011h7uREXAU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Exercises

**1.** Use the group_by function to count how many penguins were studied each year and also group them by their sex. Remember the data frame is called "penguins" and the year variable is called "year", sex is called "sex".
```{r workedexample1Groupby, exercise=TRUE}

```

```{r workedexample1Groupby-solution}
## FINAL SOLUTION ## 
penguins %>% 
  group_by(year, sex) %>% 
  count()

## OR ##

penguins %>% 
  group_by(year, sex) %>% 
  summarise(n = n())
```

**2.** Using the penguins data frame, group by both `island`, `sex` and `species` and give the average bill length (`bill_length_mm`), average bill depth (`bill_depth_mm`) and the difference between average bill length and average bill depths.
```{r workedexample2Groupby, exercise=TRUE}
 
```

```{r workedexample2Groupby-solution}
penguins %>% 
  group_by(island, sex, species) %>% 
  summarise(avg_length = mean(bill_length_mm, na.rm = T),
            avg_depth = mean(bill_depth_mm, na.rm = T),
            diff_depth = mean(bill_length_mm) - mean(bill_depth_mm))
# na.rm = T is optional, safer to use it if you're unsure if 
# your data contains NA's
```


Solution to Exercise 1:

<iframe width="560" height="315" src="https://www.youtube.com/embed/pTuGhkNCTnc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Solution to Exercise 2:

<iframe width="560" height="315" src="https://www.youtube.com/embed/Dr4b18O-aGo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Common Mistakes & Errors

Sometimes, you will encounter some errors in the `group_by` function. In this section, we'll cover what you should do when some of the common errors occur.

1. Error: Must group by variables found in `.data`

When this occurs, you are probably trying to group your data frame by a variable that isn't in the data frame. Often times, this happens because of a typo in the variable you want to select.

2. Error in eval(lhs, parent, parent) : object 'totally_real_data_frame' not found

When this error occurs, R is telling us that the data frame we are trying to make groups from does not exist. Once again, this is usually because of a typo.

3. Error in group_by(data) : could not find function "group_by"

When this occurs, it means that R can't find the `group_by` function. To fix this, you should try to load the `tidyverse` library in.

Some mistakes that you may run into when using `group_by` and `ungroup`:

* Calling for variables that are not in the data frame you plan to analyze (usually typos).

* Not calling in the tidyverse/dplyr library in R.

* Sometimes you can encounter difficulties with other functions, usually, typos will be the biggest issue.

### Next Steps

Now that you have got some experience with the `group_by` and `ungroup` functions, these links are useful resources to expand your understanding.

  - R for Data Science contains the `group_by` function with other dplyr functions: https://r4ds.had.co.nz/transform.html

  - Section 6.11 of OHI Data Science Training looks at the `group_by` function: https://ohi-science.org/data-science-training/dplyr.html#group_by-operates-on-groups)













## `summarise()`

Written by Mariam Walaa.


### Introduction

In this lesson, you will learn how to:

- Summarize a variable using `summarise()`
- Summarize groups of observations within a variable using `group_by()`

Prerequisite skills include:

- Using `group_by()`
- Using summary functions like `sum()`, `min()`, `max()`

Highlights:

- `summarise()` is often used with `group_by()`
- There are many summary functions you can use within `summarise()`
- You can even create your own functions to use within `summarise()`

![Source: https://github.com/allisonhorst/stats-illustrations Credits: Allison
Horst](https://github.com/allisonhorst/stats-illustrations/blob/master/other-stats-artwork/summary_statistics.png?raw=true){#id
.class width=750 height=500px}

### Arguments

The `summarise()` function takes the following as arguments:

| Argument         | Parameter        | Details                                                    |
|------------------|------------------|------------------------------------------------------------|
| .data            | data frame       | a data frame containing variables we want to summarize     |
| name-value pairs | name-value pairs | this takes the name of the column and the summary function |

You can read more about the arguments in the `summarise()` function's documentation
[here](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/summarise).

### Overview

This section will demonstrate how to use the `summarise()` function to summarize variables
and groups within a variable in a data set.

We will be looking at a data set of Broadway shows with variables about the performances,
attendance, and revenue for theaters that are part of The Broadway League. You can learn
more about the data set provided by Alex Cookson in [the data repository](https://github.com/tacookson/data) provided on GitHub, as well as this 
corresponding [blog post](https://www.alexcookson.com/post/most-successful-broadway-show-of-all-time/).

```{r summarise-1}
glimpse(broadway)
```

You'll notice that there are 47,524 rows and 8 columns. Each row uniquely represents a
show that occurred on a specific week. Each column, then, contains information about a
show on some particular week in some particular theatre.

#### Question 1

How many performances occurred in total?

```{r summarise-2}
broadway %>%
  summarise(total_performances = sum(performances))
```

#### Question 2

How many performances occurred per week?

```{r summarise-3}
broadway %>%
  group_by(week_ending) %>%
  summarise(total_num_performances = sum(performances), 
            .groups = 'drop')
```

#### Question 3

How many performances _and_ previews occurred per week?

```{r summarise-4}
broadway %>%
  group_by(week_ending) %>%
  summarise(total_num_performances = sum(performances),
            total_num_previews = sum(previews),
            .groups = 'drop')
```

#### Question 4

How many performances occurred _per theatre_ within each week?

```{r summarise-groups-drop, include = FALSE}
broadway %>%
  group_by(week_ending, theatre) %>%
  summarise(total_num_performances = sum(performances),
            .groups = 'drop')
```
```{r summarise-5, echo = FALSE}
decorate("summarise-groups-drop") %>%
  flair(".groups = 'drop'", color = "red") %>%
  knit_print.with_flair()
```

Notice that we include the `.groups` argument within each `summarise()` function call
(highlighted in red). We mostly do this to keep the output clean, but you can learn more
about this argument by running`?summarise` in your console.

### Exercises

This section will ask you to complete exercises based on what you've learned from the
previous section.

#### Exercise 1

How many theaters do we have in this data set?

```{r summarise-exercise-1, exercise = TRUE}

```

```{r summarise-exercise-1-hint-1}
n_distinct()
```
```{r summarise-exercise-1-hint-2}
# Try naming it something simple and clear, like n_theatres
```

```{r summarise-8, echo = FALSE}
summarise_ex1_sol <- broadway %>%
  summarise(n_theatres = n_distinct(theatre))
```


<!-- ```{r summarise-exercise-1-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex1_sol))) -->
<!-- ``` -->


#### Exercise 2

How many shows occurred per week?

```{r summarise-exercise-2, exercise = TRUE}

```

```{r summarise-exercise-2-hint-1}
n_distinct()
```
```{r summarise-exercise-2-hint-2}
# Try naming it something brief, like n_shows
```

```{r summarise-9, echo = FALSE}
summarise_ex2_sol <- broadway %>%
  group_by(week_ending) %>%
  summarise(n_shows = n_distinct(show), .groups = 'drop')
```


<!-- ```{r summarise-exercise-2-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex2_sol))) -->
<!-- ``` -->

#### Exercise 3

What is the average number of performances across all theatres per week?

```{r summarise-exercise-3, exercise = TRUE}

```

```{r summarise-exercise-3-hint-1}
# Try naming it something descriptive, like avg_num_performances
```

```{r summarise-10, echo = FALSE}
summarise_ex3_sol <- broadway %>%
  group_by(week_ending) %>%
  summarise(avg_num_performances = mean(performances), .groups = 'drop')
```


<!-- ```{r summarise-exercise-3-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex3_sol))) -->
<!-- ``` -->


#### Exercise 4

What is the minimum and maximum number of performances per week?

```{r summarise-exercise-4, exercise = TRUE}

```

```{r summarise-exercise-4-hint-1}
across()
```

```{r summarise-11, echo = FALSE}
summarise_ex4_sol <- broadway %>%
  group_by(week_ending) %>%
  summarise(across(.cols = "performances", 
                   .fns = list(min = min, max = max)), .groups = 'drop')
```


<!-- ```{r summarise-exercise-4-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex4_sol))) -->
<!-- ``` -->

#### Exercise 5

What is the average top ticket price? 

```{r summarise-exercise-5, exercise = TRUE}

```

```{r summarise-exercise-5-hint-1}
na.rm = TRUE
```

```{r summarise-12, echo = FALSE}
summarise_ex5_sol <- broadway %>%
  summarise(avg_top_price = mean(top_ticket_price, na.rm = TRUE),
            .groups = 'drop')
```


<!-- ```{r summarise-exercise-5-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex5_sol))) -->
<!-- ``` -->

#### Exercise 6

Which weeks did shows have no performances or previews?

```{r summarise-exercise-6, exercise = TRUE}

```

```{r summarise-exercise-6-hint-1}
arrange()
```

```{r summarise-13, echo = FALSE}
summarise_ex6_sol <- broadway %>%
  group_by(show, week_ending) %>%
  summarise(appearances = performances + previews, .groups = 'drop') %>%
  arrange(appearances)
```


<!-- ```{r summarise-exercise-6-check} -->
<!-- grade_result(pass_if(~identical(.result, summarise_ex6_sol))) -->
<!-- ``` -->

#### Exercise 7

Select all the true statements about the `summarise()` function from dplyr.

```{r summarise-exercise-7, echo = FALSE}
question("Which of these are true? Check all true statements.",
         answer("summarise() can be used to summarize a variable into a single number.",
                correct = TRUE),
         answer("summarise() can only use the same statistics as summary().",
                message = paste("summarise() does NOT use the same statistics as summary().",
                "We can use many more summary functions, and we can even define our own!")),
         answer("summarise() can be applied on a group-level when used in combination with group_by().",
                correct = TRUE),
         answer("summarise() and summarize() are two different functions.",
                message = "summarise() and summarize() are the same function within dplyr."),
         answer("summarise() can only use summary functions that output a single number.",
                message = paste("summarise() cannot only output a single number summary.",
                "We can use functions like quantile() which outputs multiple numbers.")),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

### Common Mistakes & Errors

Below are some common mistakes and errors you may come across:

* You try to summarize a column that has NA values. Remember to include `na.rm = TRUE`.
* You try to summarize a column that is not available in the data set (i.e., you
misspelled the column name, or it's simply not in the data set).

### Next Steps

If you would like to read more about the `summarise()` function, here are some additional
resources you may find helpful:

- [R 4 Data Science: **Chapter 5.6** Grouped summaries with
summarise](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise).
- [R 4 Data Science: 5.6.4 Useful summary functions](https://r4ds.had.co.nz/transform.html#summarise-funs)













## `arrange()`

Written by Isaac Ehrlich.


### Introduction

Sometimes, you may want to view a dataset in a specific order. Data sets will often be displayed in the order the data were input, but you may want to view it sorted by a different variable. You can use the tidyverse `arrange()` function, to order a data set by a specific column.

### arrange()

The `arrange()` function takes in a data frame and columns to sort by as its input, and will output the re-ordered data frame. `arrange()` does not modify any values in your data, it only changes the presentation.

Let's take a look at a simple example using R's `mtcars` data set:

```{r}
head(mtcars)
```

There's a lot of information in this data, like miles per gallon, number of cylinders, and displacement, but it doesn't seem to be ordered in any way.

Supposing we want to order the data frame by miles per gallon (i.e. see cars with lowest mpg at the top and highest mpg at the bottom), we can pass the following function:

```{r}
head(arrange(mtcars, mtcars$mpg))
```

Note, `arrange()` by default sorts in ascending order. If we want to sort in descending order, we can pass `desc()` to the column names:

```{r}
head(arrange(mtcars, desc(mtcars$mpg)))
```

### Additional Examples

#### Characters

`arrange()` can also sort by character vectors. In this case, `arrange()` by default will sort alphabetically. Let's take a look at R's `HairEyeColor` data set ordered by hair color:

```{r}
HairEyeColor <- data.frame(HairEyeColor)
head(arrange(HairEyeColor, HairEyeColor$Hair))
```

#### Multiple Arguments

If you pass multiple columns into arrange, it will order by columns in the order they are passed. For example, in the code below, we order the `HairEyeColor` first by hair color and then by frequency.

```{r}
head(arrange(HairEyeColor, HairEyeColor$Hair, HairEyeColor$Freq))
```

We can see that the data was first ordered alphabetically by hair color, followed by frequency.


### Practice Questions

For the following questions, please refer to R's `quakes` data set:

```{r}
head(quakes)
```

```{r arrangeq1, echo = FALSE}
question("arrange() by default sorts in descending order",
answer("True"),
answer("False", correct = TRUE),
allow_retry = TRUE)
```

```{r arrangeq2, echo = FALSE}
question("Select the correct code to sort 'quakes' by magnitude in descending order",
answer("arrange(quakes, quakes$mag)",
       message = "Remember the default!"),
answer("arrange(quakes, quakes$stations, desc(quakes$mag))",
       message = "Keep in mind what you want to sort by!"),
answer("arrange(quakes, desc(quakes$mag)", correct = TRUE),
answer("arrange(desc(quakes), quakes$mag)",
       message = "Remember what you apply 'desc()' to!"),
allow_retry = TRUE)
```

```{r arrangeq3, echo = FALSE}
question("Select the correct code to sort 'quakes' by magnitude and then by depth",
answer("arrange(quakes, quakes$mag, quakes$depth)", correct = TRUE),
answer("arrange(quakes, quakes$depth, quakes$mag))",
       message = "Keep in mind the order you want to sort by!"),
answer("arrange(quakes$mag, quakes$depth)",
       message = "Don't forget the first argument!"),
answer("arrange(quakes, c(quakes$mag, quakes$depth))",
       message = "Keep in mind how to pass multiple arguments!"),
allow_retry = TRUE)
```

### Practice Coding

The following questions will ask you to use the arrange function on your own.
For these questions, please refer to R's `quakes` data set:

```{r}
head(quakes)
```

1. Arrange the data in quakes so that it is ordered by magnitude and then by stations, both in descending order

```{r arrangeq4, exercise = TRUE}

```

### Special Cases and Common Errors

#### NA Values

Regardless of if you are sorting in ascending or descending order, NA values will be sent to the bottom of your reordered data frame.

#### Common Errors

1. The first input to arrange must be of type "data.frame," it cannot be applied to objects that are tables or matrices. Make sure to convert to a data frame using `as.data.frame()` if needed.

2. Make sure you are properly calling your column names to order by. There are several ways to do this - the expressions below all output the same result.
* `arrange(quakes, quakes$mag)`
* `arrange(quakes, col = mag)`
* `quakes %>% arrange(mag)`

Other errors are bound to pop up. Remember that Stack Overflow is your best friend!

### Overview

`arrange()` is a useful function for reorganizing the structure of your data set. While it does not change any values, it may be useful if you need to order you data by a certain variable, or even just for easier viewing.

The following video summarizes what we have gone over in this tutorial: ![](https://www.youtube.com/watch?v=Ni6_PEzqLGQ&ab_channel=DOSSToolkit)

















## `mutate()`

Written by Haoluan Chen.


### Introduction

![Image Source:https://github.com/allisonhorst/stats-illustrations/blob/master/rstats-artwork/dplyr_mutate.png, Allison Horst](https://github.com/allisonhorst/stats-illustrations/blob/master/rstats-artwork/dplyr_mutate.png?raw=true){width=400 height=300}

`mutate()` is a function in the dplyr library. It is used to create new variables in your dataset while keeping the existing variables. 

### Examples 

I generated a dataset contains student test scores and their student id for a course. 

```{r mutateexample1}
scores <- tibble(student_ID = c("1", "2", "3", "4", "5", "6"),
               test_one_score = c(87, 76, 61, 80, 72, 69),
               test_two_score = c(79, 85, 52, 72, 65, 75),
               test_three_score = c(92,79, 45, 85, 76, 73))

scores
```

Q1: What is the average test score for each student? 

we can use mutate to calculate the average test score for each student and store it as a new variable called avg_test_score,

```{r mutateQ1}
avg <- scores %>% mutate(avg_test_score = (test_one_score + test_two_score + test_three_score)/3)
avg
```

Here, we have a expression for the new variable: 

avg_test_score = (test_one_score + test_two_score + test_three_score)/3 

The left side of the expression specifies the name of the new variable and the right side of the expression specifies how to calculate the new variable.  

Now, Lets assume the following weights for this course:

* 10% for test one
* 30% for test two 
* 60% for test three

Q2: What is the final grade for each student?

```{r mutateQ2}
final <- scores %>% mutate(final_grade = 0.1*test_one_score + 0.3*test_two_score + 0.6*test_three_score)
final
```

Here, we calculate the final grade by summing the value of each test score times its weight. Then, we store the final grade it as final_grade. 

Q3: Who received the highest final grade in this course?

**Note: rank() produces a vector that contains the rank of the values in the vector that was evaluated such that the lowest value would have a rank of 1 and the second-lowest value would have a rank of 2.**

**desc() transform a vector into a format that will be sorted in descending order. **

```{r mutateQ3}
final %>% mutate(rank = rank(desc(final_grade)))
```

Here, we created a new variable called rank and specify its value using `rank()` and `desc()`. The `rank()` function produces the rank of the student final grade, but it assigns rank from lowest to largest(lowest final grade will assign to 1). So, we have to use `desc()` to get the rank from largest to lowest(largest final grade will assign to 1)

Therefore, student 1 received the highest final grade in this course. 

Q4: Did all student pass the class?

```{r mutateQ4}
final %>% mutate(pass = ifelse(final_grade>=50, TRUE, FALSE))
```

Here, we created a new variable called pass, which is a logical variable that is TRUE when student received final grade higher or equal to 50(FALSE otherwise). 

We used another function `ifelse()`, it is equivalent to if...else statement in R. It takes in 3 parameters(test_expression, x, y). If the test_expression is true, it will return x, if the test_expression is not true, it will return y. 

In this case, When the final_grade is greater or equal to 50, the pass variable will assign to TRUE. And when the final_grade is less than 50, the pass variable will assign to FALSE.

Unfortunately, student 3 failed the course :(

**Note: this question can also be done using case_when function. **


### Concept Maps 


![Source: https://github.com/rstudio/concept-maps, Monica Alonso and Greg Wilson](https://github.com/rstudio/concept-maps/blob/master/en/mutate.svg?raw=true)

### Common mistakes 

* Make sure you download dplyr and called library(dplyr) before using mutate()
* Incorrect spelling of the name of the dataset or variables
* the name of new variable should not contain space or other special symbols such as / or " 
* Make sure your expression is mathematically correct and avoid division by 0



### Exercise

#### Question 1 

Now, due to the COVID-19 the weight of this course has been changed. Consider the following weight:

* 20% for test one
* 50% for test two 
* 30% for test three

Please use the dataset(scores) to calculate the final score for each of the students and store it as new_final_score.

```{r mutatedata}
scores <- tibble(student_ID = c("1", "2", "3", "4", "5", "6"),
               test_one_score = c(87, 76, 61, 80, 72, 69),
               test_two_score = c(79, 85, 52, 72, 65, 75),
               test_three_score = c(92,79, 45, 85, 76, 73))


```


```{r mutateex1, exercise=TRUE, exercise.lines = 10}
scores


```

#### Question 2

Did everyone pass the course under this new marking scheme in Q1?
Please create a new logical variable called pass to identify if any student did not pass the course.
*Note: You may want to copy your code in Question 1 here *

```{r mutateex2, exercise=TRUE, exercise.lines = 5}

```

#### Question 3 

Please create a new variable called rank that assigns student with highest new_final_score as 1, second highest new_final_score as 2 and so on. 
*Note: You may want to copy your code in Question 1 here *

```{r mutateex3, exercise=TRUE, exercise.lines = 5}

```


#### Video Solution

![Question 1](https://youtu.be/fZck9kRLw9s)
![Question 2](https://youtu.be/Xm8qB5W4PUw)
![Question 3](https://youtu.be/QNUafgFtRvQ)


### Next steps

Now you may use other functions in dplyr to generate variables in your dataset. For example

```{r include=FALSE}
final <- scores %>% mutate(final_grade = 0.1*test_one_score + 0.3*test_two_score + 0.6*test_three_score)
final %>% mutate(pass = ifelse(final_grade>=50, TRUE, FALSE))
```

```{r next}
final %>% select(student_ID, final_grade) %>% 
  filter(final_grade>80) %>% 
  mutate(letter_grade = "A",
         reward = TRUE)
```
*As you can see you can create multiple variables within one function call by separate them using comma *

#### Other resources

R for Data Science: https://r4ds.had.co.nz/transform.html (Chapter 5.5 covers mutate() and 5.5.1 contains useful creation function)

Documentation for mutate() https://dplyr.tidyverse.org/reference/mutate.html

Vignettes(demonstration of how to use functions in dplyr including mutate()) for dplyr: https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html












## `pivot_wider()` and `pivot_longer()`

Written by Annie Collins.


### Introduction

In this lesson, you will learn how to:

- Use the function `pivot_wider()` to manipulate a data frame or tibble.
- Use the function `pivot_longer()` to manipulate a data frame or tibble.

This lesson is a yellow level skill and is part of "Tidyverse Essentials". Prerequisite skills include:

- Installing packages
- Calling libraries
- Importing data

### pivot_longer()

`pivot_longer()` takes the inputted dataset and makes it **longer** by rearranging its data to **increase the number of rows** and **decrease the number of columns**. Here, we consider "longer" in the vertical sense -- a "longer" dataset has a larger number of cells from top to bottom than a "shorter" dataset.

#### Introductory Example

This dataset (called `games`) contains a list of NBA teams and their win/loss record over the course of 10 games.

```{r games data, echo=FALSE}
games <- data.frame()
# Add team names as first column
teams <- c("Toronto Raptors", "Los Angeles Lakers", "Boston Celtics", 
           "Golden State Warriors", "Miami Heat")
games <- cbind(teams)
# Randomly create a wins and losses for each team and each game
set.seed(100)
gm1 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm2 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm3 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm4 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm5 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
games <- cbind(games, gm1, gm2, gm3, gm4, gm5)
games <- as.data.frame(games)
games
```

Run the code below and observe the effect it has on the dataset. Take note of the difference in the number of rows and columns between the two tables. This will be visualized and explained in greater detail in the following step.

```{r games-data-again, include=FALSE}
games <- data.frame()
# Add team names as first column
teams <- c("Toronto Raptors", "Los Angeles Lakers", "Boston Celtics", 
           "Golden State Warriors", "Miami Heat")
games <- cbind(teams)
# Randomly create a wins and losses for each team and each game
set.seed(100)
gm1 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm2 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm3 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm4 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
gm5 <- sample(c("w", "l"), size=5, replace=TRUE, prob=c(50,50))
games <- cbind(games, gm1, gm2, gm3, gm4, gm5)
games <- as.data.frame(games)
games
```
```{r first_example, echo=FALSE, exercise=TRUE}
pivot_longer(games, cols = c(gm1, gm2, gm3, gm4, gm5), names_to = "game number", values_to = "status")
```

### Visualizing pivot_longer()

This video will guide you through the changes that occur when applying `pivot_longer()` to our dataset.

<iframe width="560" height="315" src="https://www.youtube.com/embed/OBsQA0vyxNA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### pivot_longer() Arguments

Now let's get a bit more specific. 

You just executed the command `pivot_longer(data = games, cols = c(gm1, gm2, gm3, gm4, gm5), names_to = "game number", values_to = "status")`. What do each of the arguments within the brackets mean?

- **data**: the name of our dataframe, in this case `games`.

- **cols**: the names of the columns that will be "pivoting" or changing into a longer format. *In our example, we select all columns representing a single game, which are columns "gm1" through "gm5". We could have also written `!teams` (all columns except "teams") or `starts_with("gm")` (all the columns with a name that starts with "gm")*.

- **names_to**: a new name for the column that will be created from the former column names in **cols**. After pivoting, the former distinct columns are now all stored within one column themselves, and this argument lets you give this adjusted column a descriptive new name. If left blank, the new column name will automatically be set to "names". *In our example, we named the column "game number" since it contains "gm1" through "gm5"*.

- **values_to**: similar to **names_to**, this represents a new name for the column created for the data that was originally stored in each individual cell. If left blank, the new column name will automatically be set to "values". *In our example, we set the name to "status" since the column contains information representing each team's win or loss outcome for a given game*.


### pivot_wider()

`pivot_wider()` takes the inputted dataset and makes it **wider** by rearranging its data to **decrease the number of rows** and **increase the number of columns**. `pivot_wider()` is essentially the inverse of `pivot_longer()` - the two transformations can be used to switch a data frame back and forth between its "longer" and "wider" forms.

#### Introductory Example

This is a dataset called `games_long`, a "longer" version of `games` (the result of applying `pivot_longer()` to the original data frame).

```{r wider-dataframe, echo=FALSE}
games_long <- pivot_longer(games, cols = c(gm1, gm2, gm3, gm4, gm5), names_to = "game number", values_to = "status")
games_long
```

Run the code below and observe the effect it has on the dataset. Take note of the difference in the number of rows and columns between the two tables.

```{r wider-first-example, echo=FALSE, exercise=TRUE}
pivot_wider(data = games_long, names_from = "game number", values_from = status)
```

### Visualizing pivot_wider()

This video will guide you through the changes that occur when applying `pivot_wider()` to our data frame.

<iframe width="560" height="315" src="https://www.youtube.com/embed/PycHf7Og-sY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


### pivot_wider() Arguments

You just executed the command `pivot_wider(data = games, names_from = "game number", values_from = status)`. What do each of the arguments within the brackets mean?

- **data**: the name of our dataframe, in this case `games`.

- **names_from**: the column containing the names which will be given to the new columns once the data frame is pivoted. *In our example, we use "game number" since we want each column to contain information for a specific game*.

- **values_from**: the name (or names, in a vector) of the column containing values that will be stored at the cell level within each new column once the data frame is pivoted. *In our example, we use "status" since we want each team's win or loss results recorded in the appropriate game's column and the appropriate team's row*.

### Other Optional Arguments

#### pivot_longer()
- **names_prefix = "..."**: Removes a the stated common prefix from the beginning of each pivoted column name.
- **values_drop_na = TRUE**: If TRUE, this will remove rows containing only missing (NA) values in the **values_to** column.

#### pivot_wider()
- **names_prefix = "..."**: Adds the stated string to the beginning of each new column name from `names from` argument. This may be useful if the data contained in `names_from` is numeric and you wish to add a descriptive prefix.

- **values_fill = "..."**: replaces any missing or NA values in `values_from` with the inputted string or value.

- **names_sort = TRUE**: sorts the columns by name instead of in order of appearance.

- **names_sep = "..."**: if `names_from` or `values_from` contains multiple variables (in the form of a vector), `names_sep` allows you to state a specific string that will be used to join their names together into a single string as a column name (for example, "." or "_").


### Questions

Please reference this dataframe representing different pizza topping combinations for the following three questions:
```{r questionframe1, echo=FALSE}
type <- c("classic", "hawaiian", "veggie")
top1 <- c("cheese", "ham", "mushrooms")
top2 <- c("pepperoni", "pineapple", "peppers")
pizza <- cbind(type, top1, top2)
pizza <- as.data.frame(pizza)
pizza
```

```{r longerq1, echo=FALSE}
question("If `pivot_longer()` was applied to this dataframe on columns 'top1' and 'top2', how many rows would the output have (not including the header)?",
answer("2"),
answer("3"),
answer("6", correct=TRUE),
answer("9")
)
```

```{r longerq2, echo=FALSE}
question("If `pivot_longer()` was applied to this dataframe on columns 'top1' and 'top2', how many times would the word 'pineapple' appear in the outputted dataframe?",
answer("1", correct=TRUE),
answer("2"),
answer("3"),
answer("0")
)
```

```{r longerq3, echo=FALSE}
question("If `pivot_longer()` was applied to this dataframe on columns 'top1' and 'top2', what would the fourth row (not including header) of the outputted dataframe contain?",
answer("veggie, top1, mushrooms"),
answer("veggie, top2, peppers"),
answer("hawaiian, top1, ham"),
answer("hawaiian, top2, pineapple", correct = TRUE)
)
```


Please reference this dataframe representing different pizza topping combinations for the following three questions:
```{r questionframe2, echo=FALSE}
pivot_longer(pizza, cols=starts_with("top"), names_to = "number", values_to = "topping")
```
```{r widerq1, echo=FALSE}
question("If `pivot_wider()` was applied to this dataframe with names from \"number\" and values from \"topping\", how many columns would the output have?",
answer("2"),
answer("3", correct=TRUE),
answer("6"),
answer("9")
)
```

```{r widerq2, echo=FALSE}
question("If `pivot_wider()` was applied to this dataframe with names from \"number\" and values from \"topping\", how many times would the type \"classic\" appear in the output?",
answer("1", correct = TRUE),
answer("2"),
answer("3"),
answer("0")
)
```

```{r widerq3, echo=FALSE}
question("If `pivot_wider()` was applied to this dataframe with names from \"number\" and values from \"topping\", what would the column names be?",
answer("type, top1, top2", correct = TRUE),
answer("classic, hawaiian, veggie"),
answer("type, number, topping"),
answer("classic, cheese, pepperoni")
)
```

### Exercises

#### pivot_longer()

Original `games` data, for reference.

```{r gamesref, echo=FALSE}
games
```

**Hint**: Unless specified, there are multiple ways to select the columns you wish to pivot.

1. Pivot the data stored in all columns except "teams". Map column names to a new column called "top five" and data from pivoted columns to a new column called "outcome".

```{r longerexample1, exercise=TRUE}

```
```{r longerexample1-solution}
pivot_longer(games, cols = !teams, names_to = "top five", values_to = "outcome")
```


2. The code in the window below replaces all "l" values in "games" with NA. Run this code, then pivot this table to make it longer while removing all rows with NA values. Assign columns their default names.

```{r longerexample2, exercise=TRUE}
games[games=="l"] <- NA
games
```
```{r longerexample2-solution}
pivot_longer(data = games, cols = c(gm1, gm2, gm3, gm4, gm5), values_drop_na = TRUE)
```


#### pivot_wider()

Original `games_long` data, for reference.

```{r games_longref, echo=FALSE}
games_long
```

1. Manipulate `games_long` to look like the original `games` data frame at the top of this page.

```{r widerexample1, exercise=TRUE}

```
```{r widerexample1-solution}
pivot_wider(data = games_long, names_from = "game number", values_from = "status")
```

### Common Mistakes & Errors

- If you want to keep your dataframe in its longer or wider version, make sure to assign or reassign it to a variable when you execute `pivot_longer()`. For example, if you wish "games" to now represent the longer version of games instead of the original, you must write `games <- pivot_longer(data=games, ...)`


*Error in UseMethod("pivot_longer") : 
  no applicable method for 'pivot_longer' applied to an object of class "c('matrix', 'array', 'character')"*

- pivot_longer() only works on **dataframes** (not lists, character vectors, etc.). If you are working with something that isn't a dataframe, you can use the function `as.data.frame()` to turn your data from its original format into a dataframe.

### Next Steps

- Try more complicated pivots, like pivoting into multiple new columns at once or combining boolean statements.
- Switch your dataframe between formats using `pivot_longer()` and `pivot_wider()` as inverse functions.














## `rename()`

Written by Mariam Walaa.


### Introduction

In this lesson, you will learn how to:

- Rename columns in a data frame

Prerequisite skills include:

- Using the pipe operator

Highlights:

- We can rename multiple columns at once using `rename()`.
- It's helpful to rename columns into something simpler.
- We can name columns that don't already have a name using `rename()`.

### Arguments

The `rename()` function takes the following as arguments:

| Argument | Parameter | Details                                                           |
|----------|-----------|-------------------------------------------------------------------|
| x        | object    | this is the data with variables to rename (typically a data frame)|
| replace  | vector    | this takes a vector as c(new_name = old_name)                     |

You can read more about the arguments in the `rename()` function's documentation
[here](https://www.rdocumentation.org/packages/plyr/versions/1.8.6/topics/rename).

### Overview

Sometimes we have to work with data sets with columns that are difficult to understand or
work with. In this case, we can rename the columns using the `rename()` function.

In this tutorial, we'll be using a data set about fictional character personalities for
reference. This data set already consists of simple, clear, and well-named variables, but
we are going to try to simplify them even further using `rename()`.

We'll start by loading the data from GitHub.

```{r load-tidyverse-yet-again}
library(tidyverse)
```

```{r rename-hidden-load, echo = FALSE, message = FALSE}
personalities <- read_tsv(
  "https://raw.githubusercontent.com/tacookson/data/master/fictional-character-personalities/personalities.txt")
```
```{r rename-exercise-load, exercise = TRUE}
personalities <- read_tsv(
  "https://raw.githubusercontent.com/tacookson/data/master/fictional-character-personalities/personalities.txt")
```


Here is the dataset.

```{r rename-1}
glimpse(personalities)
```

This data consists of 213,600 rows, each representing a fictional character, and 11
columns describing the character and their personality.

We can see that the first three columns are about the character's unique ID, the fictional
work that they are from, and their name. We'll rename each of these to a single word.

```{r rename-2}
personalities <- personalities %>%
  rename(id = character_code,
         work = fictional_work,
         name = character_name)
```

We've renamed 3 columns in the data frame and re-assigned it to `personalities`.

```{r rename-3}
glimpse(personalities)
```

Now we have a data frame with renamed columns.

**Question**: What if we have a column that does not have a name? 

Idea: We can still name it by indexing the column using base R's `names()`.

```{r rename-4}
personalities %>%
  rename(fictional_work = names(.)[2])
```

Here, we change the "work" column back to "fictional_work" simply by indexing the second column in the personalities data frame. This column already had a name, but if it didn't, this method would have still successfully named it to "fictional_work".

### Exercises

#### Exercise 1

Rename the `personalities` data back to its original column names.

```{r rename-exercise-1, exercise = TRUE}

```

```{r rename-exercise-1-hint-1}
# You don't have to assign it to an object
```

```{r rename-exercise-1-sol, echo = FALSE}
rename_ex_sol <- personalities %>%
  rename(character_code = id,
         fictional_work = work,
         character_name = name)
```


<!-- ```{r rename-exercise-1-check} -->
<!-- grade_result(pass_if(~identical(.result, rename_ex_sol))) -->
<!-- ``` -->

#### Exercise 2

```{r rename-exercise-2, echo = FALSE}
question("Which of these are true? Check all true statements.",
         answer("You can rename multiple columns using `rename()`.", correct = TRUE),
         answer(paste("When you use `rename()`, you pass column name pairs as follows: ",
         "`c(old_name = new_name)`"), message = "You pass the new column name first."),
         answer("The `rename()` function is used to rename data frames.",
                message = "The `rename()` function is used to rename columns in a data frame."),
         answer("The `rename()` function renames columns by name.", correct = TRUE),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

### Common Mistakes & Errors

Below are some common mistakes and errors you may come across:

- You pass the old name first instead of the new name.
- You are not correctly typing a name. For example, if you have spaces between words, you need to type it as `FirstWord SecondWord` with `` as opposed to '' or "".
- You aren't typing the old column name correctly, because of a typo or because you didn't choose the correct type of quotation marks.

If you have other issues, check that you have loaded tidyverse or dplyr into your session! Remember that a lot of issues can come from not loading the required packages.

### Next Steps

If you would like to read more about the `rename()` function, here are some additional
resources you may find helpful:

- [R Documentation for
`rename()`](https://www.rdocumentation.org/packages/plyr/versions/1.8.6/topics/rename)












## `count()` and `uncount()`



```{r setup-again, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(learnr)
```




Written by Annie Collins.


### Introduction

In this lesson, you will learn how to:

- Use `count()` to summarize a data set.
- Use `uncount()` to produce a full data set from a table containing values and counts.

This lesson is a yellow level skill and is part of "Tidyverse Essentials". Prerequisite skills include:

- Installing packages
- Calling libraries
- Importing data

### Video Tutorial

<iframe width="560" height="315" src="https://www.youtube.com/embed/zPqeJPjYc48" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


### count()

`count()` is a function that can be used to summarize a data set in terms of the number of unique values of a certain variable or combination of variables.

Using `count()` on a data set produces a new table including each unique value or combination of values along with an integer value representing the number of times it appears in the data.

### Using count()

The data set below (`starwars`) contains information on characters in the the *Star Wars* film franchise. There are 30 unique characters in the data with five characteristics/measurements recorded for each.

```{r starwars, echo=FALSE}
starwars <- 
  starwars %>% 
  select(name, hair_color, skin_color, eye_color, homeworld, species)

starwars <- 
  filter(starwars, homeworld %in% c("Naboo", "Tatooine", "Alderaan", "Coruscant", "Kamino"))

starwars
```

Although each character is unique and only appears once in the data, there are several variables where multiple characters have the same characteristic, and we may want to know how many characters share each characteristic.

For example, we may want to examine how many characters came from each home world.

```{r count-example1, echo=TRUE}
count(starwars, homeworld)
```

We can also sort this table to see which home worlds appear in the data most frequently.

```{r count-example2, echo=TRUE}
count(starwars, homeworld, sort=TRUE)
```
Here, we see that Naboo is the most common home world, with 11 characters in the data set from this world.

If we wish to get even more specific, we could look at unique species-homeworld combinations amongst characters in the data.

```{r count-example3, echo=TRUE}
count(starwars, species, homeworld, sort=TRUE)
```
The outputted table shows that there are eight characters in the `starwars` data set that are humans from Tatooine, five that are humans from Naboo, and so on.

### count() Arguments

`count(data, variables, sort = FALSE, name = NULL)`

- **data**: the data frame you are counting from.
- **variables**: the variables in **data** you are counting, inputted by individual column name. This could be one or multiple variables to be counted in combination. If none are entered, `count()` will return a count of the total number of rows in **data**.
- **sort = ...**: FALSE by default (if omitted). If sort = TRUE, `count()` will sort the outputted table in descending order of the count column, otherwise it will be sorted in alphabetical order by the first column (with NA values last).
- **name = "..."**: NULL (empty) by default. This argument indicates the name you wish to give the column containing the count values, inputted in the form of a string. If omitted, the count column will be titled **n**.

### uncount()

`uncount()` is a function that can be used to produce a full length table from a table containing variables and counts (for example, one that was produced using the `count()` function). The function duplicates each unique variable according to the value in the count column indicated. You may think of it as the inverse of `count()`.

#### Arguments

`uncount()` takes two required arguments and two optional arguments:

`uncount(data, weights, .remove = TRUE, .id = NULL)`

- **data**: the data frame containing variables and counts.
- **weights**: the name of the column in **data** containing the counts for each variable(s). You can also use a constant or expression if you wish all variables to be duplicated the same number of times, or if an appropriate column does not exist in **data**.

**Optional**:

- **.remove = ...**: TRUE by default. If **weights** is a column in **data**, this argument indicates whether or not you want the **weights** values to remain in the outputted table. If .remove = TRUE (default), the outputted table will only contain the duplicated variables. If .return = FALSE, the outputted table will contain the duplicated variables along with their total count present in an additional column. If **weights** is a value or expression, then **.remove** does not apply and the column containing counts (if it exists) will be included in the outputted table.
- **.id = "..."**: NULL (empty) by default. This argument allows you to input a string as the title for a new column that will automatically generate a unique ID for each duplicated variable. This may be useful if you still want to distinguish between variables once they have been repeated.

### Using uncount()

To help visualize the use of `uncount()`, we will use this small data set called `colours`.

```{r colours, echo=FALSE}
colours <- data.frame()
colour <- c("red", "yellow", "blue")
n <- c(1, 2, 3)
colours <- cbind(colour, n)
colours <- as.data.frame(colours)
colours$n <- as.numeric(colours$n)
colours
```
 `colours` indicates that red occurs once, yellow occurs twice, and blue occurs three times in some data, for a total of six observations.

If we want to observe all the data in its uncounted form, we can use `uncount()`.

```{r uncount-example1, echo=TRUE}
uncount(colours, n)
```
Our output includes only one column (no count values) with each colour repeated the number of times indicated in the **n** column in `colours`. `uncount()` also automatically generates a new version of the row number according to the number of times each row was duplicated.

If we wish to duplicate each colour (regardless of the value in column **n**), we can substitute **2** in place of **n** in the function. Note that in the outputted table, the values from **n** are still present since we did not input a column for the **weights** argument.

```{r uncount-example2, echo=TRUE}
uncount(colours, 2)
```
Using the optional arguments **.remove** and **.id**, we can uncount `colours` according to column **n** while still keeping the values from **n** in the output *and* assign a unique ID number to each repeated colour.

```{r uncount-example3, echo=TRUE}
uncount(colours, n, .remove = FALSE, .id = "id")
```
Now we can distinguish between different yellow and blue rows in the column (for instance, yellow 1 and yellow 2 according to the **id** column).

Note that this does not change if there are multiple combinations of variables in `colours` we wish to uncount.

Updated `colours`:
```{r colours-meaning, echo=FALSE}
temp <- c("warm","warm", "cool")
colours <- cbind(colour, temp, n)
colours <- as.data.frame(colours)
colours$n <- as.numeric(colours$n)
colours
```
```{r uncount-example4, echo=TRUE}
uncount(colours, n, .remove = FALSE, .id = "id")
```
### Questions & Exercises

#### Exercises

For the following two exercises, manipulate the `starwars` data set to match the output displayed. The original is included below for reference.

```{r starwars2, echo=FALSE}
starwars
```

**Exercise 1**

```{r countexercise1-reference, echo=FALSE}
count(starwars, skin_color, eye_color, sort=TRUE)
```
```{r countexercise1, exercise=TRUE}

```
```{r countexercise1-solution}
count(starwars, skin_color, eye_color, sort=TRUE)
```

**Exercise 2**

```{r countexercise2-reference, echo=FALSE}
count(starwars, name, name="unique")
```
```{r countexercise2, exercise=TRUE}

```
```{r countexercise2-solution}
count(starwars, name, name="unique")
```

#### Questions

Below is the first five rows of output from **Exercise 1**, assigned the name `features`. Please use this data set as reference for the following questions.

```{r features, echo=FALSE}
features <- count(starwars, skin_color, eye_color, sort=TRUE) %>% slice(1:5)
features
```

```{r uncount-question1, echo=FALSE}
question("In the output of `uncount(features, n)`, how many times will the word \"brown\" appear?",
answer("2"),
answer("3"),
answer("7"),
answer("12", correct=TRUE)
)
```

```{r uncount-question2, echo=FALSE}
question("How many rows does the output of `uncount(features, 2)` have (not including the header)?",
answer("5"),
answer("10", correct=TRUE),
answer("21"),
answer("42")
)
```

```{r uncount-question3, echo=FALSE}
question("How many columns does the output of `uncount(features, 2)` have?",
answer("1"),
answer("2"),
answer("3", correct=TRUE),
answer("4")
)
```











## `slice()`

Written by Annie Collins.


### Introduction

In this lesson, you will learn how to:

- Select rows in a data frame using the `slice()` function

This lesson is a yellow level skill and is part of "Tidyverse Essentials". Prerequisite skills include:

- Installing packages
- Calling libraries
- Importing data

### slice()

The `slice()` function is part of the R base package (the functions that come with R) with several additional variations in the `dplyr` package.

`slice()` allows you to select rows from your data by their location in the data frame. This can be done by inputting specific row numbers, ranges of row numbers, or by choosing rows to omit from the data. The `slice()` function does not manipulate the original data frame, but rather outputs a *copy* of the original data frame including only the selected rows.

The syntax for using slice is as follows:

\center `slice(data, row number(s) of row(s) to be kept/removed)` \center

This will be further explained in the following sections.

### Video Overview

<iframe width="560" height="315" src="https://www.youtube.com/embed/Ob3hZJ0EUXM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Selecting Rows

We will be slicing the data frame below (named `pizza`) which includes data on different pizza types and their toppings. For the purposes of visualizing the `slice()` function, the row numbers have been indicated next to each pizza type.
```{r pizza, echo=FALSE}
type <- c("(1) classic", "(2) hawaiian", "(3) veggie", "(4) meat lovers", "(5) greek")
top1 <- c("cheese", "ham", "mushrooms", "sausage", "olives")
top2 <- c("pepperoni", "pineapple", "peppers", "bacon", "feta cheese")
pizza <- cbind(type, top1, top2)
pizza <- as.data.frame(pizza)
pizza
```

#### Single Row

If you wish to select a single row from your data frame, simply input the row's number into the `slice()` function following the name of your data.

The code below returns the information about a veggie pizza.
```{r slice-example1, echo=TRUE}
slice(pizza, 3)
```

#### Multiple Rows
There are several ways to slice multiple rows at once.

You may input several integers separated by commas, similar to the above example of selecting a single row. The code below returns information about classic, veggie, and greek pizzas.
```{r slice-example2, echo=TRUE}
slice(pizza, 1, 3, 5)
```

You can also input a vector of integers indicating the rows you wish to slice. This functions essentially the same as the previous method, but may be useful if you already have a numeric vector containing this information. The code below also returns information about classic, veggie, and greek pizzas.
```{r slice-example3, echo=TRUE}
nums <- c(1, 3, 5)
slice(pizza, nums)
```

If you wish to select information from multiple adjacent rows, you can input a numeric range instead of selecting rows individually. The syntax for this is "first row:last row". The code below outputs the first three rows of `pizza`.
```{r slice-example4, echo=TRUE}
slice(pizza, 1:3)
```

#### Omitting Rows
Another way of slicing rows is choosing which rows to *omit* or *remove* from the data frame. You can use any of the above methods to remove individual or multiple rows from a data frame by placing "**-**" before the inputted row number(s). The `slice()` function will then return all the rows in the data frame *except* the rows indicated. Uncomment each line of code below to observe the output.

```{r pizza2, include=FALSE}
type <- c("(1) classic", "(2) hawaiian", "(3) veggie", "(4) meat lovers", "(5) greek")
top1 <- c("cheese", "ham", "mushrooms", "sausage", "olives")
top2 <- c("pepperoni", "pineapple", "peppers", "bacon", "feta cheese")
pizza <- cbind(type, top1, top2)
pizza <- as.data.frame(pizza)
```
```{r slice-example5, exercise = TRUE}
# Return everything except row 3
slice(pizza, -3)
# Return only rows 2 and 4
# slice(pizza, -1, -3, -5)
# OR
# nums <- c(1, 3, 5)
# slice(pizza, -nums)
# Return only the last two rows (4:5)
# slice(pizza, -1:-3)
```
Note that when using `slice()`, positive and negative numbers cannot be combined. All row number values must be either positive or negative, including in vectors and ranges.

It is also possible to combine selection methods, for instance by indicating a range of rows followed by another individual row (`slice(pizza, 1:3, 5)` will return everything except row 4).

### Questions & Exercises

Please use the dataset `olympics`, representing medal counts from the 2016 summer Olympics in Rio de Janeiro, for the following questions and exercises.
```{r olympics, echo=FALSE}
country <- c("United States", "Great Britain", "China", "Russia", "Germany", "Japan", "France", "South Korea")
gold <- c(46, 27, 26, 19, 17, 12, 10, 9)
silver <- c(37, 23, 18, 17, 10, 8, 18, 3)
bronze <- c(38, 17, 26, 20, 15, 21, 14, 9)
olympics <- cbind(country, gold, silver, bronze)
olympics <- as.data.frame(olympics)
olympics
```

#### Questions

```{r slice-q1, echo=FALSE}
question("Which of the following is **not** equivalent to `slice(olympics, 1:2)?`",
answer("slice(olympics, 1, 2)"),
answer("slice(olympics, c(1, 2))"),
answer("slice(olympics, -3:-8)"),
answer("slice(olympics, 3:8)", correct=TRUE)
)
```
```{r slice-q2, echo=FALSE}
question("Which of the following will return data for all countries in `olympics`?",
answer("slice(olympics, 1:8)", correct=TRUE),
answer("slice(olympics, 8)"),
answer("slice(olympics, -1)"),
answer("slice(olympics, c(1, 8))")
)
```

#### Exercises
```{r, include=FALSE}
country <- c("United States", "Great Britain", "China", "Russia", "Germany", "Japan", "France", "South Korea")
gold <- c(46, 27, 26, 19, 17, 12, 10, 9)
silver <- c(37, 23, 18, 17, 10, 8, 18, 3)
bronze <- c(38, 17, 26, 20, 15, 21, 14, 9)
olympics <- cbind(country, gold, silver, bronze)
olympics <- as.data.frame(olympics)
```


1. Using `slice()` and a numeric vector, extract information for Russia, Germany, and Japan from `olympics`. 
```{r sliceexercise1, exercise=TRUE}

```

```{r sliceexercise1-solution}
vector <- c(4, 5, 6)
slice(olympics, vector)
```

2. Using `slice()`, show information for all countries in `olympics` except for Great Britain and France.
```{r sliceexercise2, exercise=TRUE}

```

```{r sliceexercise2-solution}
slice(olympics, -2, -7)
```

3. Using `slice()`, show only the top three gold medal winners from the 2016 Olympic games.
```{r sliceexercise3, exercise=TRUE}

```

```{r sliceexercise3-solution}
slice(olympics, 1:3)
```


### Common Mistakes

- **Slicing rows that do not exist**: Ensure you are always inputting row numbers that exist in your data. If you input row numbers that do not exist in your data (for example, `slice(pizza, 6)` when `pizza` only has 5 rows), the function will return *<0 rows> (or 0-length row.names)* which is an empty data frame. To check the number of rows in your data, you can use the function `nrow()`. You can also use `n()` to represent the number of the last row of your data regardless of length (ie. 1:n() would slice every row of a data frame).
- **Combining Positive and Negative Indexes**: As mentioned previously, all row number values must be either positive or negative when using `slice()`, including in vectors and ranges. If you combine positive and negative values, you may get the following message: *Error: \`slice()\` expressions should return either all positive or all negative.*.
- **"Losing" your sliced data frame**: When you use the `slice()` function, you are not directly changing your original data. If you want your data frame to be saved in its "sliced" form, you must reassign the name of your data frame to the output of the `slice()` function. For example, if I wanted to permanently remove the last two rows of `pizza`, I would execute the code `pizza <- slice(pizza, -4:-5)`.


### Next Steps

There are several functions that act as variations of `slice()` with similar syntax in the `dplyr` package. These include:

- `slice_head()` and `slice_tail()`, to select a number of first or last rows
- `slice_sample()`, to randomly select rows from a data frame
- `slice_min()` and `slice_max()`, to select rows with the highest or lowest value(s) of a specified variable.














## c(), matrix(), data.frame() and tibble()

Written by Matthew Wankiewicz.


### Introduction

In this lesson, you will learn:

- What a vector is and how to create one in R.
- The difference between matrices, dataframes and tibbles.
- How to create matrices, dataframes and tibbles in R.

Prerequisite skills include:

- R installed on your computer/RStudio cloud account

Highlights:

- Vectors are data structures in R which can contain numbers, words, or logical operators among others.
  - The `c()` function is usually the main way of creating vectors.
- Matrices are objects in R that contain rows and columns. These matrices can be added and subtracted along with other matrices.
  - The `matrix()` function helps with creating matrices.
- Dataframes are objects in R which are similar to matrices. Dataframes can be built out of multiple vectors.
  - The `data.frame()` function allows us to create dataframes in R.
- Tibbles are dataframes, but they are easier to use with functions in R. Since R has been in use for many years, tibbles allow us to do more with data, when compared to dataframes.
  - The `tibble()` function creates tibbles in R.

### The content

- Vectors are a type of data structure in R which contains observations of the same type. Vectors can include sets of numbers, a group of names or a group of randomly selected logical operators (True or False). When creating a vector, R requires all elements of the vector to be the same type, this means that it is possible to create vectors with numbers and words, but the numbers will be stored as characters. 

- Matrices are two dimensional and are similar to the structure of vectors. Matrices can contain words and numbers, but are mainly used with numbers. Matrices are usually created with numbers because there is the ability to conduct matrix operations like addition, subtraction, division and multiplication between different matrices. Matrices have a fixed number of rows and columns.

- Dataframes are another way of storing data and are mainly used for storing tables. The benefit to using dataframes over matrices is when your data contains numbers and words. Dataframes are able to contain columns of numbers and columns of words while matrices can only contain numbers or words. Dataframes are also useful because it is possible to conduct operations between columns, which will be shown in the Questions section of this lesson.

- As mentioned in the introduction, tibbles are very similar to dataframes but they are more compatible with current uses for R. This is because some older operations in R aren't as useful as they were when R was created, so tibbles had to be created to make some operations run better. Tibbles are created using the `tibble()` function which can be found in the `tidyverse` package, which is different than the other data types discussed above, because they can be created using the base R functions. 


### Vectors

- **`c()`:** The `c()` function takes one main argument and includes optional arguments. The main argument for `c()` are the values that you want to save as a vector. The arguments used can be any set of numbers or words, or both. For example we would use an entry could be: `test <- c("This", "is", "example", 1)`. If you do save numbers in words in the same vector, R will convert the number into a character instead of keeping it as an integer.
  
  - The optional arguments for `c()` are `recursive =` and `use.names =`. The recursive function is useful when the items you are vectoring includes a list. If you set `recursive = TRUE` it breaks down the list and converts it into a vector. If `recursive = FALSE` the vector is saved as a list (by default, `recursive = FALSE`, and it usually stays that way). The argument `use.names =` tells R whether or not to keep the names of the lists present when the vector is saved.
  
#### Examples

You can easily create vectors using the `c()` function. Run the code chunk below to see.
```{r ex1vectors, exercise = T}
vector1 <- c(1, 2, 3, 4)
vector1
```

As mentioned in previous sections of this lesson, you can create a vector of both numbers and words, but the numbers will be saved as characters.
```{r ex2vectors, exercise = T}
vector2 <- c("stats", "is", "number", 1)
vector2

## using class tells us the class of the objects in the vector 
class(vector2)
```

You can also index vectors by using square brackets ([]). To index a value of an R vector, write the vector name and then in the square brackets, the position of that value in the vector.
```{r ex3vectors, exercise = T}
vector <- c("a", "b", "c", "d", "e") ## save our vector

vector[3] ## if we want to select c, it is the third element so we write vector[3]

vector[-3] ## if we want to return the vector without the letter c, type vector[-3]
```

We can also add, subtract, multiply and divide vectors.
```{r add-vectors, exercise = TRUE}
vec1 <- c(2, 4, 6)
vec2 <- c(3, 6, 9)

vec1 + vec2
vec1*vec2
```


### Matrices

- **`matrix()`:** The `matrix()` function takes 5 arguments, 3 of them are the most important. The first one is `data`, which is the data you plan to make a matrix with, this can contain multiple vectors. The next argument is `nrow` which is the number of rows you want to have and `ncol` which is the number of columns you want to include in your matrix.

  - There are two optional arguments, `byrow` and `dimnames`. `byrow` can either be true or false, if false, the entries for the matrix are added by filling out the columns as opposed to filling out the data row by row. `dimnames` allows you to name the rows and the columns of your matrix.
  
#### Examples

If we use the matrix function on a set of numbers without specifying the number of rows/columns, you get a matrix with one column.
```{r ex1matrices, exercise = T}
matrix1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9))
matrix1
```

Using the `nrow` and `ncol` arguments, we can tell R how we want our matrix to look. 
```{r ex2matrices, exercise = T}
matrix2 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
matrix2
```

The next chunk will show the use the `byrow` argument to fill out our matrix. You will notice that when comparing the output of this chunk to the one above, other than the diagonals, the entries are all different.
```{r ex3matrices, exercise = T}
matrix3 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = T)
matrix3
```

We can also add, subtract, multiply and divide matrices
```{r add-matrices, exercise = TRUE}
mat1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = T)
mat1
mat2 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = F)
mat2

mat1 - mat2

mat1/mat2
```


We can also multiply vectors and matrices
```{r vector-times-matrix, exercise = TRUE}
mat1 <- matrix(c(1:9), nrow = 3)
mat1
vec1 <- c(1:3)
vec1

mat1*vec1
```

Be sure to notice that multiplication with vectors and matrics is different from typical operations between vectors and matrices. In R these operation will be conducted by elements, which is why for the example above we don't get a 1x3 vector. 

Matrices can be also indexed.
```{r index-matrices, exercise = TRUE}
mat2 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = F)
mat2

mat2[3,3] ## third row, third column
```
  

  
### Data Frames

- **`data.frame()`:** The main argument that `data.frame()` takes is the data that you want to become a dataframe. To name the columns, you can write `"name" = c()` where c() is the vector of numbers/words. You can name each column by repeating the `"name" = c()` line. The other important argument is `row.names`. For this argument you can write a name for each row in a vector that has the same length as the number of rows as your dataframe. 

  - `data.frame()` contains 4 optional arguments. `check.rows` checks if the rows are consistent in their length and names. `check.names` checks if your column names are unique and there aren't any repeats. `fix.empty.names` automatically names any columns with missing variable names (this is set to true by default). Lastly, `stringsAsFactors` converts character vectors into factors if set to true (set to true by default).
  
#### Examples

As mentioned in the Arguments section, there are many ways to create a dataframe. For this one, we'll just insert two vectors into the function, without naming them.
```{r ex1Dataframes, exercise = T}
data.frame(c(1,2,3), c(2,4,6))
```
We can see that without naming the vectors, `data.frame()` names the rows "c.1..2..3" and "c.2..4..6".


Now we can do the same as above, but save the vectors beforehand and then add them into the function.
```{r ex2Dataframes, exercise = T}
vector1 <- c(1:3) ## this is another way writing 1,2,3
data.frame(vector1, vector2 = c(2,4,6))
```

We can also take a matrix and convert the matrix into a dataframe. We can also use the `row.names` argument.
```{r ex3Dataframes, exercise = T}
mat <- matrix(1:9, nrow = 3)
mat

df <- data.frame(mat, row.names = c("a", "b", "c"))
df
```


For the last example of making dataframes, we will make use of the `check.names` and `stringsAsFactors` arguments
```{r ex4Dataframes, exercise = T}
vector1 <- c(1:3)
df <- data.frame(vector1, vector1 = c("one", "two", "three"), check.names = TRUE, 
                 stringsAsFactors = TRUE)
df

class(df$vector1.1)
```
We can see that the dataframe has two columns, vector1 and vector1.1 and if we don't do that, the columns will have the same name and will be a headache to work with. Also note that the class of the `vector1.1` column is now a factor. It was initially written as a vector with characters in it, but the `stringsAsFactors` has now changed it a factor.


We can also index values in dataframes.
```{r ex5Dataframes, exercise = T}
df <- data.frame(c(1,2,3), c(2,4,6), c(3, 6, 9))

df[2,2] #to select the number 4 in the center we write df[2,2]

df[,2] ## to return the whole 2nd column, write df[,2]

df[2,] ## to select only the 2nd row, write df[2,]

df[-1,] ## you can also return dataframes without rows/columns by including "-"
```
  
### Tibbles

- **`tibble()`:** Similar to `data.frame()`, the main argument for `tibble()` is the data you want to turn into a tibble. The data can include vectors, matrices and even dataframes. You can name the columns in a similar way to `data.frame()` by writing the name and then the data you want to be stored in that column.

  - There are two optional arguments for `tibble()`, they are `.rows` and `.name_repair`. `.rows` tells R how many rows you want your tibble to be, you do not have to fill this argument out but it can be useful if you want to confirm that your data has the same amount of rows as you wish. If the number of rows given into the main argument does not match the `.rows` argument, an error will occur. `.name_repair` helps fix issues with column names, it has 5 types of repair. "Minimal" does not change or check column names, "Unique" makes sure names are not empty, "check_unique" makes sure the names are unique, "universal" checks that the names are unique and follow proper syntax. The final option for `.name_repair` is a custom function you can create on your own so the names follow a certain style.

#### Questions

Like dataframes, tibbles can be created from vectors
```{r ex1Tibbles, exercise = T}
vector1 <- c(1:3)
vector2 <- c(2,4,6)

data <- tibble(vector1, vector2)
data
```

Tibbles can also be created from matrices. This can be done using the `as_tibble()` function.
```{r ex2Tibbles, exercise = T, warning=F}
mat1 <- matrix(1:9, nrow = 3, ncol = 3) ## 3x3 matrix
mat1

tib <- as_tibble(mat1)
tib
```

Similarly, dataframes can be converted into tibbles.
```{r ex3Tibbles, exercise = T}
df1 <- data.frame("id" = c(1,2,3), "sport" = c("soccer", "baseball", "basketball"),
                  "name" = c("Messi", "Bichette", "James"))
df1

tibble(df1, .rows = 3) ## we can use .rows to confirm that there will be 3 rows.
```

Tibbles can also be indexed.
```{r index-tibbles, exercise = T}
tib1 <- tibble(data.frame("id" = c(1,2,3), "sport" = c("soccer", "baseball", "basketball"),
                  "name" = c("Messi", "Bichette", "James")))
tib1

tib1[1,3] ## 1st row, 3rd column
```

If we create an identical dataframe and tibble and index the same location, we will get a tibble from the tibble and a specific value from the dataframe
```{r index-tibble-dataframe, exercise = T}
df_index <- data.frame(x = c(1:3), y = c(4:6), z = c(7:9))

tib_index <- tibble(df_index)


df_index[2,2]
tib_index[2,2]
```
The dataframe gives us the integer 5 while the tibble gives us a 1x1 tibble with 5 as the only entry.


Lastly, you can make tibbles where the columns are mathematical operations between columns.
```{r ex4Tibbles, exercise = T}
col1 <- c(1:10)
tibble(col1, col2 = col1+10, col3 = (col1+col2)*100)
```


### Exercises

```{r quiz1-vectors, echo=F}
question_checkbox( "1. Which data types are part of base R? Select all that apply.",
  answer("Tibbles"),
  answer("Dataframes", correct = T),
  answer("Vectors", correct = T),
  answer("Matrices", correct = T),
  incorrect = paste0("Incorrect."),
  allow_retry = T,
  random_answer_order = T
)
```


**2.** This question will combine vectors and dataframes. Create two vectors, the first one (call it 'numbers') containing the numbers 10, 20, 30 and 40, and the second one (call it 'cities') containing the words: 'Toronto', 'New York', 'Boston' and 'Vancouver'. Now, take those two vectors and turn them into a dataframe. (Hint: The `c()` and `data.frame()` function will be very helpful.)
```{r quiz2-vectors, exercise = TRUE}
## Enter code below
numbers <- 
cities <- 
```

```{r quiz2-vectors-solution}

numbers <- c(10, 20, 30, 40)
cities <- c('Toronto', 'New York', 'Boston', 'Vancouver')
data.frame(numbers, cities)
```

**3.** Make a tibble with the first column being the set of numbers from 1 to 10, the second column being the first column times 7 and the third column being the sum of columns 1 and 2.

```{r quiz3-vectors, exercise = TRUE}
## enter code below
col1 <- 
```

```{r quiz3-vectors-solution}

col1 <- c(1:10)
tibble(col1, col2 = col1*7, col3 = col1 + col2) 

## OR

col1 <- c(1:10)
col2 <- col1*7
col3 <- col1 + col2

tibble(col1, col2, col3)
```


**4.** The next question follows the code chunk below.

```{r quiz4-tibble, results = "hide"}
cities <- c("Toronto", "New York", "Vancouver", "Montreal", "Chicago", "Los Angeles")
rank <- c(1, 2, 3, 4, 5, 6)

tibble(cities, rank, pop = rank*1000, 
       rank_plus_pop = rank + pop)
```

```{r quiz4-tibble1, echo=F}
question("How many columns are present in the data?",
         answer("4", correct = TRUE),
         answer("3"),
         answer("2"),
         answer("5"))
```

```{r quiz4-tibble2, echo=F}
question("What would be that class of the output of the `tibble` function?",
         answer("Vector"),
         answer("Matrix"),
         answer("Tibble or (tbl)", correct = T),
         answer("None of the options."))
```

```{r quiz4-tibble3, echo=F}
question("How many rows will the data have?",
         answer("7"),
         answer("3"),
         answer("6", correct = T),
         answer("5"))
```


**5.** For this exercise, create a dataframe containing 3 vectors: one containing a set of 5 numbers, another containing a set of 5 animals and another containing a set of 5 cities. Name the columns of this dataframe 'id', 'animal', 'city'. Save this dataframe under the name 'df' and then convert it into a tibble.
```{r vec-df-ex1, exercise = TRUE}
## enter code below
```

```{r vec-df-ex1-solution}

## Your answers may be different
df <- data.frame(id = c(1:5), animal = c("Dog", "Cat", "Goat", "Bird", "Lion"),
                 city = c("Toronto", "San Diego", "New York", "Boston", "Washington")
                 )
tibble(df)

## OR

id <- c(1:5)
animal <- c("Dog", "Cat", "Goat", "Bird", "Lion")
city <- c("Toronto", "San Diego", "New York", "Boston", "Washington")

df <- data.frame(id, animal, city)
tibble(df)
```

### Common Mistakes & Errors

- **Vectors**
  - If you try to index a vector and the vector returns 'NA', that likely means that you are trying to index an element that isn't in your vector. To fix this, you need to include a number that is **less than or equal to** the length of your vector.

- **Matrices**
  - Error in matrix[n,m] : subscript out of bounds
    - This error means that you are trying to index a point in the matrix that doesn't exist. Similar to vectors, move the subscript to be inside the lengths of your matrix.
  - In matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 4, byrow = F) :
  data length [9] is not a sub-multiple or multiple of the number of rows [4]
    - This error means that the number of rows you are trying to use does not fit the amount of numbers you want to use in the matrix. If you want **n** rows, make sure the length of your matrix is divisible by **n**.
  - Error in mat1 + mat2 : non-conformable arrays
    - This error occurs when you try to do mathematical operations on matrices that aren't compatible. This goes back to linear algebra where you need to have similar length between matrices to conduct operations between them.
  
- **Dataframes**
  - Similar to matrices and vectors, you can encounter issues with indexing. Once again, make sure you keep you indexing within the limits of your dataframe.
  - Error in data.frame(c(1, 2, 3), c("a", "b")) : 
  arguments imply differing number of rows: 3, 2
    - This error will occur when the vectors you are trying to make into a dataframe have different lengths. To fix this, make sure your vectors are the same length.

- **Tibbles**
  - Often times, you can use functions like `filter()` or `group_by()` on tibbles and usually when you encounter errors, the error will be with how the function is executed. 
  - Error: Tibble columns must have compatible sizes.
    - This means that when you used the tibble function, the vectors you included were not the same length. To fix this, make sure all vectors are of the same length.

### Next Steps

Now that you understand what vectors, matrices, dataframes and tibbles are. Some next steps include:

- Using dplyr functions with tibbles: https://uomresearchit.github.io/r-tidyverse-intro/04-dplyr/
- Looking at R for Data Science's chapter on tibbles: https://r4ds.had.co.nz/tibbles.html
- The vector chapter in R4DS: https://r4ds.had.co.nz/vectors.html










## length(), nrow() and ncol(), and dim()

Written by Isaac Ehrlich.

### Introduction

Understanding the size and dimensions of your variables can be important in a variety of contexts.

In this lesson, you will learn how to

- Use `length()` to find the length of vectors
- Use `nrow()` and `ncol()` to find the dimensions of matrices and data frames
- Use `dim()` to find and set dimensions

Prerequisites:

- Understanding how to create vectors and data frames and their basic principles

### Arguments

#### length()
`length()` returns the length (number of items) in a vector. The only argument that `length()` takes is the vector.

```{r lengthExample}
x <- c("a", "b", "c", "d")
length(x)
```


#### nrow() and ncol()

`nrow()` and `ncol()` return the number of rows and columns of a matrix or data frame, respectively. The only argument that `nrow()` and `ncol()` take is the matrix or data frame.

```{r nrowExample}
df <- data.frame(col1 = c("a", "b", "c", "d"), col2 = c(1,2,3,4))
df

# Number of Rows:
nrow(df)

# Number of Columns:
ncol(df)
```

#### dim()

`dim()` returns a vector with two elements that denote the dimensions of a matrix or data frame, in the order 'number of rows', 'number of columns'. The first element is equivalent to the output of `nrow()` and the second to that of `ncol()`. Similarly to `nrow()` and `ncol()`, the only argument that `dim()` takes is the matrix or data frame.
```{r dimExample1}
# Dimensions of data frame:
dim(df)

# Note the relationship between 'dim()', 'nrow()', and 'ncol()'
dim(df)[1] == nrow(df)
dim(df)[2] == ncol(df)
```

Unlike `nrow()` and `ncol()` however, `dim()` can also be used to set the dimensions of a vector or matrix. Setting dimensions for a vector will turn it into a matrix.
```{r dimExample2}
# Create a vector
x <- c("a", "b", "c", "d")
# Check dimensions of x - should output NULL since vectors do not have dimensions
dim (x)

# Set and check new dimensions
dim(x) <- c(2, 2)
dim(x)

# Output 'x'
x
```

Setting new dimensions for an existing matrix will reshape it.
```{r}
# Create a matrix and check its dimensions
m <- matrix(1:12)
dim(m)

# Set and check new dimensions
dim(m) <- c(3,4)
dim(m)
```


#### `dplyr::bind_rows()` and `dplyr::bind_cols()`

Finally, it is worth mentioning that there are also `dplyr` versions of `rbind()` and `cbind()`. `dplyr::bind_rows()` is actually a bit more robust since it doesn't require the input data frames to have the same number of columns. If you are making extensive use of `rbind()` and `cbind()`, then exploring their `dplyr` counterparts would be worthwhile.


### Questions and Exercises

####  length()

For questions about `length()` we will be using the built in vector `fruit`, a vector of fruit names.

**1.**

```{r length-q1, echo = FALSE}
question("length() returns the following information:",
answer("The number of characters in a string"),
answer("The number of objects in a vector", correct = TRUE),
answer("The length (in centimeters) printing a vector will occupy on your screen"),
allow_retry = TRUE)
```


**2. Save the length of the vector `fruit` as the variable `fruit_len`**

```{r length-q2, echo = FALSE, exercise = TRUE}
# Enter your code below

fruit_len <- 
fruit_len
```

```{r length-q2-solution}
fruit_len <- length(fruit)

```

**3. Using indexing and the `length()` function, return the final object in `fruit`**

```{r length-q3, echo = FALSE, exercise = TRUE}
# Enter your code below

last_fruit <- 
last_fruit
```

```{r length-q3-solution}
last_fruit <- fruit[length(fruit)]
```

#### nrow() and ncol()

For questions about `nrow()` and `ncol()` we will be using the data frame `starwars`, which contains Star Wars characters and information about them, and a secret matrix.

**1. Save the number of rows and number of columns in `starwars`**

```{r nrow-q1, echo = FALSE, exercise = TRUE}
# Enter your code below

starwars_rows <- 
starwars_cols <- 

starwars_rows
starwars_cols
```

```{r nrow-q1-solution}
starwars_rows <- nrow(starwars)
starwars_cols <- ncol(starwars)
```

**2. I've created a matrix, `secret_matrix`, the dimensions of which are a secret. Without printing out the number of rows and columns, check to see if `secret_matrix` is a square matrix (i.e. it has the same number of rows and columns)**

```{r, echo = FALSE}
secret_matrix <- matrix(1:12, 3, 4)
```


```{r nrow-q2, echo = FALSE, exercise = TRUE}
# Enter your code below

```

```{r nrow-q2-solution}
nrow(secret_matrix) == ncol(secret_matrix)
```

**3. Using indexing, `nrow()`, and `ncol()`, in one line, save the value in the bottom right corner of the matrix `secret_matrix`.**

```{r nrow-q3, echo = FALSE, exercise = TRUE}
# Enter your code below
bottom_right_value <- secret_matrix[]

bottom_right_value
```

```{r nrow-q3-solution}
bottom_right_value <- secret_matrix[nrow(secret_matrix), ncol(secret_matrix)]
```

#### dim()

**1.**
```{r dim-q1, echo = FALSE}
question("Which of the following are true about the relationship between 'dim()', 'nrow()', and 'ncol()'? Select all that apply.",
answer("There is no relationship"),
answer("The first element of the output of dim(x) is equal to the output of nrow(x)", correct = TRUE),
answer("It depends on whether or not the input is a matrix or data frame"),
answer("The second element of the output of dim(x) is equal to the output of ncol(x)", correct = TRUE),
allow_retry = TRUE)
```

**2. Use `dim()` to turn the `fruit` vector into a matrix with 8 rows and 10 columns**
```{r dim-q2, exercise = TRUE}
# Enter your code here

dim(fruit)
```

```{r dim-q2-solution}
dim(fruit) <- c(8, 10)
```


### Special Cases & Common Mistakes

#### length()

* Remember that `length()` returns the number of objects in a vector, not the number of digits or characters in a string. See examples below.
```{r length-special-ex1}
length("This sentence has 31 characters")
length(c("This sentence has 31 characters", "This sentence has 7 less"))
```

* Although a vector is the correct input into `length()`, if the input is a dataframe, the output will be equal to the number of columns.
```{r length-special-ex2}
length(starwars) == ncol(starwars)
```

* If the input is a matrix, the output will be equal to the number of entries in the matrix.
```{r length-special-ex3}
length(secret_matrix) == nrow(secret_matrix) * ncol(secret_matrix)
```


#### nrow() and ncol()

* Using a vector as input to `nrow()`, `ncol()`, or `dim()` will output `NULL`
```{r nrow-special}
# Check dimensions of 'letters', a built-in vector of English letters
nrow(letters)
ncol(letters)
dim(letters)
```


### Overview and Next Steps

`length()`, `nrow()`, and `ncol()`, are useful functions for finding the dimensions of variables. In the next section, we will continue exploring data frames and how to manipulate them.



















## Summary, and next steps


In this level, we covered many of the fundational verbs that will be a large part of your R life. You'll use these again and again. But don't worry if you can't remember everything initially. It'll all start to make sense eventually.

Great work! In the next level we fill in some base R programming functions. You can start the next lesson by running:

```{r, eval = FALSE}
learnr::run_tutorial("totally_addicted_to_base", package = "DoSStoolkit")
```






